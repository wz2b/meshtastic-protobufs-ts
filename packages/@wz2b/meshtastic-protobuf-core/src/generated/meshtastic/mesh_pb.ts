// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=js"
// @generated from file meshtastic/mesh.proto (package meshtastic, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Channel } from "./channel_pb.js";
import { file_meshtastic_channel } from "./channel_pb.js";
import type { Config, Config_DeviceConfig_Role } from "./config_pb.js";
import { file_meshtastic_config } from "./config_pb.js";
import type { ModuleConfig, RemoteHardwarePin } from "./module_config_pb.js";
import { file_meshtastic_module_config } from "./module_config_pb.js";
import type { PortNum } from "./portnums_pb.js";
import { file_meshtastic_portnums } from "./portnums_pb.js";
import type { DeviceMetrics } from "./telemetry_pb.js";
import { file_meshtastic_telemetry } from "./telemetry_pb.js";
import type { XModem } from "./xmodem_pb.js";
import { file_meshtastic_xmodem } from "./xmodem_pb.js";
import type { DeviceUIConfig } from "./device_ui_pb.js";
import { file_meshtastic_device_ui } from "./device_ui_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file meshtastic/mesh.proto.
 */
export const file_meshtastic_mesh: GenFile = /*@__PURE__*/
  fileDesc("ChVtZXNodGFzdGljL21lc2gucHJvdG8SCm1lc2h0YXN0aWMihwcKCFBvc2l0aW9uEhcKCmxhdGl0dWRlX2kYASABKA9IAIgBARIYCgtsb25naXR1ZGVfaRgCIAEoD0gBiAEBEhUKCGFsdGl0dWRlGAMgASgFSAKIAQESDAoEdGltZRgEIAEoBxI3Cg9sb2NhdGlvbl9zb3VyY2UYBSABKA4yHi5tZXNodGFzdGljLlBvc2l0aW9uLkxvY1NvdXJjZRI3Cg9hbHRpdHVkZV9zb3VyY2UYBiABKA4yHi5tZXNodGFzdGljLlBvc2l0aW9uLkFsdFNvdXJjZRIRCgl0aW1lc3RhbXAYByABKAcSHwoXdGltZXN0YW1wX21pbGxpc19hZGp1c3QYCCABKAUSGQoMYWx0aXR1ZGVfaGFlGAkgASgRSAOIAQESKAobYWx0aXR1ZGVfZ2VvaWRhbF9zZXBhcmF0aW9uGAogASgRSASIAQESDAoEUERPUBgLIAEoDRIMCgRIRE9QGAwgASgNEgwKBFZET1AYDSABKA0SFAoMZ3BzX2FjY3VyYWN5GA4gASgNEhkKDGdyb3VuZF9zcGVlZBgPIAEoDUgFiAEBEhkKDGdyb3VuZF90cmFjaxgQIAEoDUgGiAEBEhMKC2ZpeF9xdWFsaXR5GBEgASgNEhAKCGZpeF90eXBlGBIgASgNEhQKDHNhdHNfaW5fdmlldxgTIAEoDRIRCglzZW5zb3JfaWQYFCABKA0SEwoLbmV4dF91cGRhdGUYFSABKA0SEgoKc2VxX251bWJlchgWIAEoDRIWCg5wcmVjaXNpb25fYml0cxgXIAEoDSJOCglMb2NTb3VyY2USDQoJTE9DX1VOU0VUEAASDgoKTE9DX01BTlVBTBABEhAKDExPQ19JTlRFUk5BTBACEhAKDExPQ19FWFRFUk5BTBADImIKCUFsdFNvdXJjZRINCglBTFRfVU5TRVQQABIOCgpBTFRfTUFOVUFMEAESEAoMQUxUX0lOVEVSTkFMEAISEAoMQUxUX0VYVEVSTkFMEAMSEgoOQUxUX0JBUk9NRVRSSUMQBEINCgtfbGF0aXR1ZGVfaUIOCgxfbG9uZ2l0dWRlX2lCCwoJX2FsdGl0dWRlQg8KDV9hbHRpdHVkZV9oYWVCHgocX2FsdGl0dWRlX2dlb2lkYWxfc2VwYXJhdGlvbkIPCg1fZ3JvdW5kX3NwZWVkQg8KDV9ncm91bmRfdHJhY2si2AEKBFVzZXISCgoCaWQYASABKAkSEQoJbG9uZ19uYW1lGAIgASgJEhIKCnNob3J0X25hbWUYAyABKAkSEwoHbWFjYWRkchgEIAEoDEICGAESKwoIaHdfbW9kZWwYBSABKA4yGS5tZXNodGFzdGljLkhhcmR3YXJlTW9kZWwSEwoLaXNfbGljZW5zZWQYBiABKAgSMgoEcm9sZRgHIAEoDjIkLm1lc2h0YXN0aWMuQ29uZmlnLkRldmljZUNvbmZpZy5Sb2xlEhIKCnB1YmxpY19rZXkYCCABKAwiWgoOUm91dGVEaXNjb3ZlcnkSDQoFcm91dGUYASADKAcSEwoLc25yX3Rvd2FyZHMYAiADKAUSEgoKcm91dGVfYmFjaxgDIAMoBxIQCghzbnJfYmFjaxgEIAMoBSLiAwoHUm91dGluZxIzCg1yb3V0ZV9yZXF1ZXN0GAEgASgLMhoubWVzaHRhc3RpYy5Sb3V0ZURpc2NvdmVyeUgAEjEKC3JvdXRlX3JlcGx5GAIgASgLMhoubWVzaHRhc3RpYy5Sb3V0ZURpc2NvdmVyeUgAEjEKDGVycm9yX3JlYXNvbhgDIAEoDjIZLm1lc2h0YXN0aWMuUm91dGluZy5FcnJvckgAIrACCgVFcnJvchIICgROT05FEAASDAoITk9fUk9VVEUQARILCgdHT1RfTkFLEAISCwoHVElNRU9VVBADEhAKDE5PX0lOVEVSRkFDRRAEEhIKDk1BWF9SRVRSQU5TTUlUEAUSDgoKTk9fQ0hBTk5FTBAGEg0KCVRPT19MQVJHRRAHEg8KC05PX1JFU1BPTlNFEAgSFAoQRFVUWV9DWUNMRV9MSU1JVBAJEg8KC0JBRF9SRVFVRVNUECASEgoOTk9UX0FVVEhPUklaRUQQIRIOCgpQS0lfRkFJTEVEECISFgoSUEtJX1VOS05PV05fUFVCS0VZECMSGQoVQURNSU5fQkFEX1NFU1NJT05fS0VZECQSIQodQURNSU5fUFVCTElDX0tFWV9VTkFVVEhPUklaRUQQJUIJCgd2YXJpYW50IssBCgREYXRhEiQKB3BvcnRudW0YASABKA4yEy5tZXNodGFzdGljLlBvcnROdW0SDwoHcGF5bG9hZBgCIAEoDBIVCg13YW50X3Jlc3BvbnNlGAMgASgIEgwKBGRlc3QYBCABKAcSDgoGc291cmNlGAUgASgHEhIKCnJlcXVlc3RfaWQYBiABKAcSEAoIcmVwbHlfaWQYByABKAcSDQoFZW1vamkYCCABKAcSFQoIYml0ZmllbGQYCSABKA1IAIgBAUILCglfYml0ZmllbGQivAEKCFdheXBvaW50EgoKAmlkGAEgASgNEhcKCmxhdGl0dWRlX2kYAiABKA9IAIgBARIYCgtsb25naXR1ZGVfaRgDIAEoD0gBiAEBEg4KBmV4cGlyZRgEIAEoDRIRCglsb2NrZWRfdG8YBSABKA0SDAoEbmFtZRgGIAEoCRITCgtkZXNjcmlwdGlvbhgHIAEoCRIMCgRpY29uGAggASgHQg0KC19sYXRpdHVkZV9pQg4KDF9sb25naXR1ZGVfaSJsChZNcXR0Q2xpZW50UHJveHlNZXNzYWdlEg0KBXRvcGljGAEgASgJEg4KBGRhdGEYAiABKAxIABIOCgR0ZXh0GAMgASgJSAASEAoIcmV0YWluZWQYBCABKAhCEQoPcGF5bG9hZF92YXJpYW50IpsFCgpNZXNoUGFja2V0EgwKBGZyb20YASABKAcSCgoCdG8YAiABKAcSDwoHY2hhbm5lbBgDIAEoDRIjCgdkZWNvZGVkGAQgASgLMhAubWVzaHRhc3RpYy5EYXRhSAASEwoJZW5jcnlwdGVkGAUgASgMSAASCgoCaWQYBiABKAcSDwoHcnhfdGltZRgHIAEoBxIOCgZyeF9zbnIYCCABKAISEQoJaG9wX2xpbWl0GAkgASgNEhAKCHdhbnRfYWNrGAogASgIEjEKCHByaW9yaXR5GAsgASgOMh8ubWVzaHRhc3RpYy5NZXNoUGFja2V0LlByaW9yaXR5Eg8KB3J4X3Jzc2kYDCABKAUSMwoHZGVsYXllZBgNIAEoDjIeLm1lc2h0YXN0aWMuTWVzaFBhY2tldC5EZWxheWVkQgIYARIQCgh2aWFfbXF0dBgOIAEoCBIRCglob3Bfc3RhcnQYDyABKA0SEgoKcHVibGljX2tleRgQIAEoDBIVCg1wa2lfZW5jcnlwdGVkGBEgASgIEhAKCG5leHRfaG9wGBIgASgNEhIKCnJlbGF5X25vZGUYEyABKA0SEAoIdHhfYWZ0ZXIYFCABKA0ifgoIUHJpb3JpdHkSCQoFVU5TRVQQABIHCgNNSU4QARIOCgpCQUNLR1JPVU5EEAoSCwoHREVGQVVMVBBAEgwKCFJFTElBQkxFEEYSDAoIUkVTUE9OU0UQUBIICgRISUdIEGQSCQoFQUxFUlQQbhIHCgNBQ0sQeBIHCgNNQVgQfyJCCgdEZWxheWVkEgwKCE5PX0RFTEFZEAASFQoRREVMQVlFRF9CUk9BRENBU1QQARISCg5ERUxBWUVEX0RJUkVDVBACQhEKD3BheWxvYWRfdmFyaWFudCKlAgoITm9kZUluZm8SCwoDbnVtGAEgASgNEh4KBHVzZXIYAiABKAsyEC5tZXNodGFzdGljLlVzZXISJgoIcG9zaXRpb24YAyABKAsyFC5tZXNodGFzdGljLlBvc2l0aW9uEgsKA3NuchgEIAEoAhISCgpsYXN0X2hlYXJkGAUgASgHEjEKDmRldmljZV9tZXRyaWNzGAYgASgLMhkubWVzaHRhc3RpYy5EZXZpY2VNZXRyaWNzEg8KB2NoYW5uZWwYByABKA0SEAoIdmlhX21xdHQYCCABKAgSFgoJaG9wc19hd2F5GAkgASgNSACIAQESEwoLaXNfZmF2b3JpdGUYCiABKAgSEgoKaXNfaWdub3JlZBgLIAEoCEIMCgpfaG9wc19hd2F5InQKCk15Tm9kZUluZm8SEwoLbXlfbm9kZV9udW0YASABKA0SFAoMcmVib290X2NvdW50GAggASgNEhcKD21pbl9hcHBfdmVyc2lvbhgLIAEoDRIRCglkZXZpY2VfaWQYDCABKAwSDwoHcGlvX2VudhgNIAEoCSLAAQoJTG9nUmVjb3JkEg8KB21lc3NhZ2UYASABKAkSDAoEdGltZRgCIAEoBxIOCgZzb3VyY2UYAyABKAkSKgoFbGV2ZWwYBCABKA4yGy5tZXNodGFzdGljLkxvZ1JlY29yZC5MZXZlbCJYCgVMZXZlbBIJCgVVTlNFVBAAEgwKCENSSVRJQ0FMEDISCQoFRVJST1IQKBILCgdXQVJOSU5HEB4SCAoESU5GTxAUEgkKBURFQlVHEAoSCQoFVFJBQ0UQBSJQCgtRdWV1ZVN0YXR1cxILCgNyZXMYASABKAUSDAoEZnJlZRgCIAEoDRIOCgZtYXhsZW4YAyABKA0SFgoObWVzaF9wYWNrZXRfaWQYBCABKA0i+QUKCUZyb21SYWRpbxIKCgJpZBgBIAEoDRIoCgZwYWNrZXQYAiABKAsyFi5tZXNodGFzdGljLk1lc2hQYWNrZXRIABIpCgdteV9pbmZvGAMgASgLMhYubWVzaHRhc3RpYy5NeU5vZGVJbmZvSAASKQoJbm9kZV9pbmZvGAQgASgLMhQubWVzaHRhc3RpYy5Ob2RlSW5mb0gAEiQKBmNvbmZpZxgFIAEoCzISLm1lc2h0YXN0aWMuQ29uZmlnSAASKwoKbG9nX3JlY29yZBgGIAEoCzIVLm1lc2h0YXN0aWMuTG9nUmVjb3JkSAASHAoSY29uZmlnX2NvbXBsZXRlX2lkGAcgASgNSAASEgoIcmVib290ZWQYCCABKAhIABIwCgxtb2R1bGVDb25maWcYCSABKAsyGC5tZXNodGFzdGljLk1vZHVsZUNvbmZpZ0gAEiYKB2NoYW5uZWwYCiABKAsyEy5tZXNodGFzdGljLkNoYW5uZWxIABIuCgtxdWV1ZVN0YXR1cxgLIAEoCzIXLm1lc2h0YXN0aWMuUXVldWVTdGF0dXNIABIqCgx4bW9kZW1QYWNrZXQYDCABKAsyEi5tZXNodGFzdGljLlhNb2RlbUgAEi4KCG1ldGFkYXRhGA0gASgLMhoubWVzaHRhc3RpYy5EZXZpY2VNZXRhZGF0YUgAEkQKFm1xdHRDbGllbnRQcm94eU1lc3NhZ2UYDiABKAsyIi5tZXNodGFzdGljLk1xdHRDbGllbnRQcm94eU1lc3NhZ2VIABIoCghmaWxlSW5mbxgPIAEoCzIULm1lc2h0YXN0aWMuRmlsZUluZm9IABI8ChJjbGllbnROb3RpZmljYXRpb24YECABKAsyHi5tZXNodGFzdGljLkNsaWVudE5vdGlmaWNhdGlvbkgAEjQKDmRldmljZXVpQ29uZmlnGBEgASgLMhoubWVzaHRhc3RpYy5EZXZpY2VVSUNvbmZpZ0gAQhEKD3BheWxvYWRfdmFyaWFudCKDAQoSQ2xpZW50Tm90aWZpY2F0aW9uEhUKCHJlcGx5X2lkGAEgASgNSACIAQESDAoEdGltZRgCIAEoBxIqCgVsZXZlbBgDIAEoDjIbLm1lc2h0YXN0aWMuTG9nUmVjb3JkLkxldmVsEg8KB21lc3NhZ2UYBCABKAlCCwoJX3JlcGx5X2lkIjEKCEZpbGVJbmZvEhEKCWZpbGVfbmFtZRgBIAEoCRISCgpzaXplX2J5dGVzGAIgASgNIpQCCgdUb1JhZGlvEigKBnBhY2tldBgBIAEoCzIWLm1lc2h0YXN0aWMuTWVzaFBhY2tldEgAEhgKDndhbnRfY29uZmlnX2lkGAMgASgNSAASFAoKZGlzY29ubmVjdBgEIAEoCEgAEioKDHhtb2RlbVBhY2tldBgFIAEoCzISLm1lc2h0YXN0aWMuWE1vZGVtSAASRAoWbXF0dENsaWVudFByb3h5TWVzc2FnZRgGIAEoCzIiLm1lc2h0YXN0aWMuTXF0dENsaWVudFByb3h5TWVzc2FnZUgAEioKCWhlYXJ0YmVhdBgHIAEoCzIVLm1lc2h0YXN0aWMuSGVhcnRiZWF0SABCEQoPcGF5bG9hZF92YXJpYW50IkAKCkNvbXByZXNzZWQSJAoHcG9ydG51bRgBIAEoDjITLm1lc2h0YXN0aWMuUG9ydE51bRIMCgRkYXRhGAIgASgMIocBCgxOZWlnaGJvckluZm8SDwoHbm9kZV9pZBgBIAEoDRIXCg9sYXN0X3NlbnRfYnlfaWQYAiABKA0SJAocbm9kZV9icm9hZGNhc3RfaW50ZXJ2YWxfc2VjcxgDIAEoDRInCgluZWlnaGJvcnMYBCADKAsyFC5tZXNodGFzdGljLk5laWdoYm9yImQKCE5laWdoYm9yEg8KB25vZGVfaWQYASABKA0SCwoDc25yGAIgASgCEhQKDGxhc3RfcnhfdGltZRgDIAEoBxIkChxub2RlX2Jyb2FkY2FzdF9pbnRlcnZhbF9zZWNzGAQgASgNItcCCg5EZXZpY2VNZXRhZGF0YRIYChBmaXJtd2FyZV92ZXJzaW9uGAEgASgJEhwKFGRldmljZV9zdGF0ZV92ZXJzaW9uGAIgASgNEhMKC2NhblNodXRkb3duGAMgASgIEg8KB2hhc1dpZmkYBCABKAgSFAoMaGFzQmx1ZXRvb3RoGAUgASgIEhMKC2hhc0V0aGVybmV0GAYgASgIEjIKBHJvbGUYByABKA4yJC5tZXNodGFzdGljLkNvbmZpZy5EZXZpY2VDb25maWcuUm9sZRIWCg5wb3NpdGlvbl9mbGFncxgIIAEoDRIrCghod19tb2RlbBgJIAEoDjIZLm1lc2h0YXN0aWMuSGFyZHdhcmVNb2RlbBIZChFoYXNSZW1vdGVIYXJkd2FyZRgKIAEoCBIOCgZoYXNQS0MYCyABKAgSGAoQZXhjbHVkZWRfbW9kdWxlcxgMIAEoDSILCglIZWFydGJlYXQiVQoVTm9kZVJlbW90ZUhhcmR3YXJlUGluEhAKCG5vZGVfbnVtGAEgASgNEioKA3BpbhgCIAEoCzIdLm1lc2h0YXN0aWMuUmVtb3RlSGFyZHdhcmVQaW4iZQoOQ2h1bmtlZFBheWxvYWQSEgoKcGF5bG9hZF9pZBgBIAEoDRITCgtjaHVua19jb3VudBgCIAEoDRITCgtjaHVua19pbmRleBgDIAEoDRIVCg1wYXlsb2FkX2NodW5rGAQgASgMIh8KDXJlc2VuZF9jaHVua3MSDgoGY2h1bmtzGAEgAygNIqoBChZDaHVua2VkUGF5bG9hZFJlc3BvbnNlEhIKCnBheWxvYWRfaWQYASABKA0SGgoQcmVxdWVzdF90cmFuc2ZlchgCIAEoCEgAEhkKD2FjY2VwdF90cmFuc2ZlchgDIAEoCEgAEjIKDXJlc2VuZF9jaHVua3MYBCABKAsyGS5tZXNodGFzdGljLnJlc2VuZF9jaHVua3NIAEIRCg9wYXlsb2FkX3ZhcmlhbnQq0A0KDUhhcmR3YXJlTW9kZWwSCQoFVU5TRVQQABIMCghUTE9SQV9WMhABEgwKCFRMT1JBX1YxEAISEgoOVExPUkFfVjJfMV8xUDYQAxIJCgVUQkVBTRAEEg8KC0hFTFRFQ19WMl8wEAUSDgoKVEJFQU1fVjBQNxAGEgoKBlRfRUNITxAHEhAKDFRMT1JBX1YxXzFQMxAIEgsKB1JBSzQ2MzEQCRIPCgtIRUxURUNfVjJfMRAKEg0KCUhFTFRFQ19WMRALEhgKFExJTFlHT19UQkVBTV9TM19DT1JFEAwSDAoIUkFLMTEyMDAQDRILCgdOQU5PX0cxEA4SEgoOVExPUkFfVjJfMV8xUDgQDxIPCgtUTE9SQV9UM19TMxAQEhQKEE5BTk9fRzFfRVhQTE9SRVIQERIRCg1OQU5PX0cyX1VMVFJBEBISDQoJTE9SQV9UWVBFEBMSCwoHV0lQSE9ORRAUEg4KCldJT19XTTExMTAQFRILCgdSQUsyNTYwEBYSEwoPSEVMVEVDX0hSVV8zNjAxEBcSGgoWSEVMVEVDX1dJUkVMRVNTX0JSSURHRRAYEg4KClNUQVRJT05fRzEQGRIMCghSQUsxMTMxMBAaEhQKEFNFTlNFTE9SQV9SUDIwNDAQGxIQCgxTRU5TRUxPUkFfUzMQHBINCglDQU5BUllPTkUQHRIPCgtSUDIwNDBfTE9SQRAeEg4KClNUQVRJT05fRzIQHxIRCg1MT1JBX1JFTEFZX1YxECASDgoKTlJGNTI4NDBESxAhEgcKA1BQUhAiEg8KC0dFTklFQkxPQ0tTECMSEQoNTlJGNTJfVU5LTk9XThAkEg0KCVBPUlREVUlOTxAlEg8KC0FORFJPSURfU0lNECYSCgoGRElZX1YxECcSFQoRTlJGNTI4NDBfUENBMTAwNTkQKBIKCgZEUl9ERVYQKRILCgdNNVNUQUNLECoSDQoJSEVMVEVDX1YzECsSEQoNSEVMVEVDX1dTTF9WMxAsEhMKD0JFVEFGUFZfMjQwMF9UWBAtEhcKE0JFVEFGUFZfOTAwX05BTk9fVFgQLhIMCghSUElfUElDTxAvEhsKF0hFTFRFQ19XSVJFTEVTU19UUkFDS0VSEDASGQoVSEVMVEVDX1dJUkVMRVNTX1BBUEVSEDESCgoGVF9ERUNLEDISDgoKVF9XQVRDSF9TMxAzEhEKDVBJQ09NUFVURVJfUzMQNBIPCgtIRUxURUNfSFQ2MhA1EhIKDkVCWVRFX0VTUDMyX1MzEDYSEQoNRVNQMzJfUzNfUElDTxA3Eg0KCUNIQVRURVJfMhA4Eh4KGkhFTFRFQ19XSVJFTEVTU19QQVBFUl9WMV8wEDkSIAocSEVMVEVDX1dJUkVMRVNTX1RSQUNLRVJfVjFfMBA6EgsKB1VOUEhPTkUQOxIMCghURF9MT1JBQxA8EhMKD0NERUJZVEVfRU9SQV9TMxA9Eg8KC1RXQ19NRVNIX1Y0ED4SFgoSTlJGNTJfUFJPTUlDUk9fRElZED8SHwobUkFESU9NQVNURVJfOTAwX0JBTkRJVF9OQU5PEEASHAoYSEVMVEVDX0NBUFNVTEVfU0VOU09SX1YzEEESHQoZSEVMVEVDX1ZJU0lPTl9NQVNURVJfVDE5MBBCEh0KGUhFTFRFQ19WSVNJT05fTUFTVEVSX0UyMTMQQxIdChlIRUxURUNfVklTSU9OX01BU1RFUl9FMjkwEEQSGQoVSEVMVEVDX01FU0hfTk9ERV9UMTE0EEUSFgoSU0VOU0VDQVBfSU5ESUNBVE9SEEYSEwoPVFJBQ0tFUl9UMTAwMF9FEEcSCwoHUkFLMzE3MhBIEgoKBldJT19FNRBJEhoKFlJBRElPTUFTVEVSXzkwMF9CQU5ESVQQShITCg9NRTI1TFMwMV80WTEwVEQQSxIYChRSUDIwNDBfRkVBVEhFUl9SRk05NRBMEhUKEU01U1RBQ0tfQ09SRUJBU0lDEE0SEQoNTTVTVEFDS19DT1JFMhBOEg0KCVJQSV9QSUNPMhBPEhIKDk01U1RBQ0tfQ09SRVMzEFASEQoNU0VFRURfWElBT19TMxBREgsKB01TMjRTRjEQUhIMCghUTE9SQV9DNhBTEg8KC1dJU01FU0hfVEFQEFQSDQoJUk9VVEFTVElDEFUSDAoITUVTSF9UQUIQVhIMCghNRVNITElOSxBXEhIKDlhJQU9fTlJGNTJfS0lUEFgSEAoMVEhJTktOT0RFX00xEFkSEAoMVEhJTktOT0RFX00yEFoSDwoLVF9FVEhfRUxJVEUQWxIPCgpQUklWQVRFX0hXEP8BKiwKCUNvbnN0YW50cxIICgRaRVJPEAASFQoQREFUQV9QQVlMT0FEX0xFThDpASq0AgoRQ3JpdGljYWxFcnJvckNvZGUSCAoETk9ORRAAEg8KC1RYX1dBVENIRE9HEAESFAoQU0xFRVBfRU5URVJfV0FJVBACEgwKCE5PX1JBRElPEAMSDwoLVU5TUEVDSUZJRUQQBBIVChFVQkxPWF9VTklUX0ZBSUxFRBAFEg0KCU5PX0FYUDE5MhAGEhkKFUlOVkFMSURfUkFESU9fU0VUVElORxAHEhMKD1RSQU5TTUlUX0ZBSUxFRBAIEgwKCEJST1dOT1VUEAkSEgoOU1gxMjYyX0ZBSUxVUkUQChIRCg1SQURJT19TUElfQlVHEAsSIAocRkxBU0hfQ09SUlVQVElPTl9SRUNPVkVSQUJMRRAMEiIKHkZMQVNIX0NPUlJVUFRJT05fVU5SRUNPVkVSQUJMRRANKtMCCg9FeGNsdWRlZE1vZHVsZXMSEQoNRVhDTFVERURfTk9ORRAAEg8KC01RVFRfQ09ORklHEAESEQoNU0VSSUFMX0NPTkZJRxACEhMKD0VYVE5PVElGX0NPTkZJRxAEEhcKE1NUT1JFRk9SV0FSRF9DT05GSUcQCBIUChBSQU5HRVRFU1RfQ09ORklHEBASFAoQVEVMRU1FVFJZX0NPTkZJRxAgEhQKEENBTk5FRE1TR19DT05GSUcQQBIRCgxBVURJT19DT05GSUcQgAESGgoVUkVNT1RFSEFSRFdBUkVfQ09ORklHEIACEhgKE05FSUdIQk9SSU5GT19DT05GSUcQgAQSGwoWQU1CSUVOVExJR0hUSU5HX0NPTkZJRxCACBIbChZERVRFQ1RJT05TRU5TT1JfQ09ORklHEIAQEhYKEVBBWENPVU5URVJfQ09ORklHEIAgQl8KE2NvbS5nZWVrc3ZpbGxlLm1lc2hCCk1lc2hQcm90b3NaImdpdGh1Yi5jb20vbWVzaHRhc3RpYy9nby9nZW5lcmF0ZWSqAhRNZXNodGFzdGljLlByb3RvYnVmc7oCAGIGcHJvdG8z", [file_meshtastic_channel, file_meshtastic_config, file_meshtastic_module_config, file_meshtastic_portnums, file_meshtastic_telemetry, file_meshtastic_xmodem, file_meshtastic_device_ui]);

/**
 *
 * A GPS Position
 *
 * @generated from message meshtastic.Position
 */
export type Position = Message<"meshtastic.Position"> & {
  /**
   *
   * The new preferred location encoding, multiply by 1e-7 to get degrees
   * in floating point
   *
   * @generated from field: optional sfixed32 latitude_i = 1;
   */
  latitudeI?: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: optional sfixed32 longitude_i = 2;
   */
  longitudeI?: number;

  /**
   *
   * In meters above MSL (but see issue #359)
   *
   * @generated from field: optional int32 altitude = 3;
   */
  altitude?: number;

  /**
   *
   * This is usually not sent over the mesh (to save space), but it is sent
   * from the phone so that the local device can set its time if it is sent over
   * the mesh (because there are devices on the mesh without GPS or RTC).
   * seconds since 1970
   *
   * @generated from field: fixed32 time = 4;
   */
  time: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: meshtastic.Position.LocSource location_source = 5;
   */
  locationSource: Position_LocSource;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: meshtastic.Position.AltSource altitude_source = 6;
   */
  altitudeSource: Position_AltSource;

  /**
   *
   * Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
   *
   * @generated from field: fixed32 timestamp = 7;
   */
  timestamp: number;

  /**
   *
   * Pos. timestamp milliseconds adjustment (rarely available or required)
   *
   * @generated from field: int32 timestamp_millis_adjust = 8;
   */
  timestampMillisAdjust: number;

  /**
   *
   * HAE altitude in meters - can be used instead of MSL altitude
   *
   * @generated from field: optional sint32 altitude_hae = 9;
   */
  altitudeHae?: number;

  /**
   *
   * Geoidal separation in meters
   *
   * @generated from field: optional sint32 altitude_geoidal_separation = 10;
   */
  altitudeGeoidalSeparation?: number;

  /**
   *
   * Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
   * - PDOP is sufficient for most cases
   * - for higher precision scenarios, HDOP and VDOP can be used instead,
   *   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
   * TODO: REMOVE/INTEGRATE
   *
   * @generated from field: uint32 PDOP = 11;
   */
  PDOP: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 HDOP = 12;
   */
  HDOP: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 VDOP = 13;
   */
  VDOP: number;

  /**
   *
   * GPS accuracy (a hardware specific constant) in mm
   *   multiplied with DOP to calculate positional accuracy
   * Default: "'bout three meters-ish" :)
   *
   * @generated from field: uint32 gps_accuracy = 14;
   */
  gpsAccuracy: number;

  /**
   *
   * Ground speed in m/s and True North TRACK in 1/100 degrees
   * Clarification of terms:
   * - "track" is the direction of motion (measured in horizontal plane)
   * - "heading" is where the fuselage points (measured in horizontal plane)
   * - "yaw" indicates a relative rotation about the vertical axis
   * TODO: REMOVE/INTEGRATE
   *
   * @generated from field: optional uint32 ground_speed = 15;
   */
  groundSpeed?: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: optional uint32 ground_track = 16;
   */
  groundTrack?: number;

  /**
   *
   * GPS fix quality (from NMEA GxGGA statement or similar)
   *
   * @generated from field: uint32 fix_quality = 17;
   */
  fixQuality: number;

  /**
   *
   * GPS fix type 2D/3D (from NMEA GxGSA statement)
   *
   * @generated from field: uint32 fix_type = 18;
   */
  fixType: number;

  /**
   *
   * GPS "Satellites in View" number
   *
   * @generated from field: uint32 sats_in_view = 19;
   */
  satsInView: number;

  /**
   *
   * Sensor ID - in case multiple positioning sensors are being used
   *
   * @generated from field: uint32 sensor_id = 20;
   */
  sensorId: number;

  /**
   *
   * Estimated/expected time (in seconds) until next update:
   * - if we update at fixed intervals of X seconds, use X
   * - if we update at dynamic intervals (based on relative movement etc),
   *   but "AT LEAST every Y seconds", use Y
   *
   * @generated from field: uint32 next_update = 21;
   */
  nextUpdate: number;

  /**
   *
   * A sequence number, incremented with each Position message to help
   *   detect lost updates if needed
   *
   * @generated from field: uint32 seq_number = 22;
   */
  seqNumber: number;

  /**
   *
   * Indicates the bits of precision set by the sending node
   *
   * @generated from field: uint32 precision_bits = 23;
   */
  precisionBits: number;
};

/**
 * Describes the message meshtastic.Position.
 * Use `create(PositionSchema)` to create a new message.
 */
export const PositionSchema: GenMessage<Position> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 0);

/**
 *
 * How the location was acquired: manual, onboard GPS, external (EUD) GPS
 *
 * @generated from enum meshtastic.Position.LocSource
 */
export enum Position_LocSource {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: LOC_UNSET = 0;
   */
  LOC_UNSET = 0,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: LOC_MANUAL = 1;
   */
  LOC_MANUAL = 1,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: LOC_INTERNAL = 2;
   */
  LOC_INTERNAL = 2,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: LOC_EXTERNAL = 3;
   */
  LOC_EXTERNAL = 3,
}

/**
 * Describes the enum meshtastic.Position.LocSource.
 */
export const Position_LocSourceSchema: GenEnum<Position_LocSource> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 0, 0);

/**
 *
 * How the altitude was acquired: manual, GPS int/ext, etc
 * Default: same as location_source if present
 *
 * @generated from enum meshtastic.Position.AltSource
 */
export enum Position_AltSource {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: ALT_UNSET = 0;
   */
  ALT_UNSET = 0,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: ALT_MANUAL = 1;
   */
  ALT_MANUAL = 1,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: ALT_INTERNAL = 2;
   */
  ALT_INTERNAL = 2,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: ALT_EXTERNAL = 3;
   */
  ALT_EXTERNAL = 3,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: ALT_BAROMETRIC = 4;
   */
  ALT_BAROMETRIC = 4,
}

/**
 * Describes the enum meshtastic.Position.AltSource.
 */
export const Position_AltSourceSchema: GenEnum<Position_AltSource> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 0, 1);

/**
 *
 * Broadcast when a newly powered mesh node wants to find a node num it can use
 * Sent from the phone over bluetooth to set the user id for the owner of this node.
 * Also sent from nodes to each other when a new node signs on (so all clients can have this info)
 * The algorithm is as follows:
 * when a node starts up, it broadcasts their user and the normal flow is for all
 * other nodes to reply with their User as well (so the new node can build its nodedb)
 * If a node ever receives a User (not just the first broadcast) message where
 * the sender node number equals our node number, that indicates a collision has
 * occurred and the following steps should happen:
 * If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
 * new User who just tried to sign in: it gets to keep its nodenum.
 * We send a broadcast message of OUR User (we use a broadcast so that the other node can
 * receive our message, considering we have the same id - it also serves to let
 * observers correct their nodedb) - this case is rare so it should be okay.
 * If any node receives a User where the macaddr is GTE than their local macaddr,
 * they have been vetoed and should pick a new random nodenum (filtering against
 * whatever it knows about the nodedb) and rebroadcast their User.
 * A few nodenums are reserved and will never be requested:
 * 0xff - broadcast
 * 0 through 3 - for future use
 *
 * @generated from message meshtastic.User
 */
export type User = Message<"meshtastic.User"> & {
  /**
   *
   * A globally unique ID string for this user.
   * In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
   * Note: app developers are encouraged to also use the following standard
   * node IDs "^all" (for broadcast), "^local" (for the locally connected node)
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   *
   * A full name for this user, i.e. "Kevin Hester"
   *
   * @generated from field: string long_name = 2;
   */
  longName: string;

  /**
   *
   * A VERY short name, ideally two characters.
   * Suitable for a tiny OLED screen
   *
   * @generated from field: string short_name = 3;
   */
  shortName: string;

  /**
   *
   * Deprecated in Meshtastic 2.1.x
   * This is the addr of the radio.
   * Not populated by the phone, but added by the esp32 when broadcasting
   *
   * @generated from field: bytes macaddr = 4 [deprecated = true];
   * @deprecated
   */
  macaddr: Uint8Array;

  /**
   *
   * TBEAM, HELTEC, etc...
   * Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
   * Apps will still need the string here for older builds
   * (so OTA update can find the right image), but if the enum is available it will be used instead.
   *
   * @generated from field: meshtastic.HardwareModel hw_model = 5;
   */
  hwModel: HardwareModel;

  /**
   *
   * In some regions Ham radio operators have different bandwidth limitations than others.
   * If this user is a licensed operator, set this flag.
   * Also, "long_name" should be their licence number.
   *
   * @generated from field: bool is_licensed = 6;
   */
  isLicensed: boolean;

  /**
   *
   * Indicates that the user's role in the mesh
   *
   * @generated from field: meshtastic.Config.DeviceConfig.Role role = 7;
   */
  role: Config_DeviceConfig_Role;

  /**
   *
   * The public key of the user's device.
   * This is sent out to other nodes on the mesh to allow them to compute a shared secret key.
   *
   * @generated from field: bytes public_key = 8;
   */
  publicKey: Uint8Array;
};

/**
 * Describes the message meshtastic.User.
 * Use `create(UserSchema)` to create a new message.
 */
export const UserSchema: GenMessage<User> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 1);

/**
 *
 * A message used in a traceroute
 *
 * @generated from message meshtastic.RouteDiscovery
 */
export type RouteDiscovery = Message<"meshtastic.RouteDiscovery"> & {
  /**
   *
   * The list of nodenums this packet has visited so far to the destination.
   *
   * @generated from field: repeated fixed32 route = 1;
   */
  route: number[];

  /**
   *
   * The list of SNRs (in dB, scaled by 4) in the route towards the destination.
   *
   * @generated from field: repeated int32 snr_towards = 2;
   */
  snrTowards: number[];

  /**
   *
   * The list of nodenums the packet has visited on the way back from the destination.
   *
   * @generated from field: repeated fixed32 route_back = 3;
   */
  routeBack: number[];

  /**
   *
   * The list of SNRs (in dB, scaled by 4) in the route back from the destination.
   *
   * @generated from field: repeated int32 snr_back = 4;
   */
  snrBack: number[];
};

/**
 * Describes the message meshtastic.RouteDiscovery.
 * Use `create(RouteDiscoverySchema)` to create a new message.
 */
export const RouteDiscoverySchema: GenMessage<RouteDiscovery> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 2);

/**
 *
 * A Routing control Data packet handled by the routing module
 *
 * @generated from message meshtastic.Routing
 */
export type Routing = Message<"meshtastic.Routing"> & {
  /**
   * @generated from oneof meshtastic.Routing.variant
   */
  variant: {
    /**
     *
     * A route request going from the requester
     *
     * @generated from field: meshtastic.RouteDiscovery route_request = 1;
     */
    value: RouteDiscovery;
    case: "routeRequest";
  } | {
    /**
     *
     * A route reply
     *
     * @generated from field: meshtastic.RouteDiscovery route_reply = 2;
     */
    value: RouteDiscovery;
    case: "routeReply";
  } | {
    /**
     *
     * A failure in delivering a message (usually used for routing control messages, but might be provided
     * in addition to ack.fail_id to provide details on the type of failure).
     *
     * @generated from field: meshtastic.Routing.Error error_reason = 3;
     */
    value: Routing_Error;
    case: "errorReason";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message meshtastic.Routing.
 * Use `create(RoutingSchema)` to create a new message.
 */
export const RoutingSchema: GenMessage<Routing> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 3);

/**
 *
 * A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
 * details on the type of failure).
 *
 * @generated from enum meshtastic.Routing.Error
 */
export enum Routing_Error {
  /**
   *
   * This message is not a failure
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   *
   * Our node doesn't have a route to the requested destination anymore.
   *
   * @generated from enum value: NO_ROUTE = 1;
   */
  NO_ROUTE = 1,

  /**
   *
   * We received a nak while trying to forward on your behalf
   *
   * @generated from enum value: GOT_NAK = 2;
   */
  GOT_NAK = 2,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TIMEOUT = 3;
   */
  TIMEOUT = 3,

  /**
   *
   * No suitable interface could be found for delivering this packet
   *
   * @generated from enum value: NO_INTERFACE = 4;
   */
  NO_INTERFACE = 4,

  /**
   *
   * We reached the max retransmission count (typically for naive flood routing)
   *
   * @generated from enum value: MAX_RETRANSMIT = 5;
   */
  MAX_RETRANSMIT = 5,

  /**
   *
   * No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
   *
   * @generated from enum value: NO_CHANNEL = 6;
   */
  NO_CHANNEL = 6,

  /**
   *
   * The packet was too big for sending (exceeds interface MTU after encoding)
   *
   * @generated from enum value: TOO_LARGE = 7;
   */
  TOO_LARGE = 7,

  /**
   *
   * The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
   * (possibly due to bad channel permissions)
   *
   * @generated from enum value: NO_RESPONSE = 8;
   */
  NO_RESPONSE = 8,

  /**
   *
   * Cannot send currently because duty cycle regulations will be violated.
   *
   * @generated from enum value: DUTY_CYCLE_LIMIT = 9;
   */
  DUTY_CYCLE_LIMIT = 9,

  /**
   *
   * The application layer service on the remote node received your request, but considered your request somehow invalid
   *
   * @generated from enum value: BAD_REQUEST = 32;
   */
  BAD_REQUEST = 32,

  /**
   *
   * The application layer service on the remote node received your request, but considered your request not authorized
   * (i.e you did not send the request on the required bound channel)
   *
   * @generated from enum value: NOT_AUTHORIZED = 33;
   */
  NOT_AUTHORIZED = 33,

  /**
   *
   * The client specified a PKI transport, but the node was unable to send the packet using PKI (and did not send the message at all)
   *
   * @generated from enum value: PKI_FAILED = 34;
   */
  PKI_FAILED = 34,

  /**
   *
   * The receiving node does not have a Public Key to decode with
   *
   * @generated from enum value: PKI_UNKNOWN_PUBKEY = 35;
   */
  PKI_UNKNOWN_PUBKEY = 35,

  /**
   *
   * Admin packet otherwise checks out, but uses a bogus or expired session key
   *
   * @generated from enum value: ADMIN_BAD_SESSION_KEY = 36;
   */
  ADMIN_BAD_SESSION_KEY = 36,

  /**
   *
   * Admin packet sent using PKC, but not from a public key on the admin key list
   *
   * @generated from enum value: ADMIN_PUBLIC_KEY_UNAUTHORIZED = 37;
   */
  ADMIN_PUBLIC_KEY_UNAUTHORIZED = 37,
}

/**
 * Describes the enum meshtastic.Routing.Error.
 */
export const Routing_ErrorSchema: GenEnum<Routing_Error> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 3, 0);

/**
 *
 * (Formerly called SubPacket)
 * The payload portion fo a packet, this is the actual bytes that are sent
 * inside a radio packet (because from/to are broken out by the comms library)
 *
 * @generated from message meshtastic.Data
 */
export type Data = Message<"meshtastic.Data"> & {
  /**
   *
   * Formerly named typ and of type Type
   *
   * @generated from field: meshtastic.PortNum portnum = 1;
   */
  portnum: PortNum;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: bytes payload = 2;
   */
  payload: Uint8Array;

  /**
   *
   * Not normally used, but for testing a sender can request that recipient
   * responds in kind (i.e. if it received a position, it should unicast back it's position).
   * Note: that if you set this on a broadcast you will receive many replies.
   *
   * @generated from field: bool want_response = 3;
   */
  wantResponse: boolean;

  /**
   *
   * The address of the destination node.
   * This field is is filled in by the mesh radio device software, application
   * layer software should never need it.
   * RouteDiscovery messages _must_ populate this.
   * Other message types might need to if they are doing multihop routing.
   *
   * @generated from field: fixed32 dest = 4;
   */
  dest: number;

  /**
   *
   * The address of the original sender for this message.
   * This field should _only_ be populated for reliable multihop packets (to keep
   * packets small).
   *
   * @generated from field: fixed32 source = 5;
   */
  source: number;

  /**
   *
   * Only used in routing or response messages.
   * Indicates the original message ID that this message is reporting failure on. (formerly called original_id)
   *
   * @generated from field: fixed32 request_id = 6;
   */
  requestId: number;

  /**
   *
   * If set, this message is intened to be a reply to a previously sent message with the defined id.
   *
   * @generated from field: fixed32 reply_id = 7;
   */
  replyId: number;

  /**
   *
   * Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
   * a message a heart or poop emoji.
   *
   * @generated from field: fixed32 emoji = 8;
   */
  emoji: number;

  /**
   *
   * Bitfield for extra flags. First use is to indicate that user approves the packet being uploaded to MQTT.
   *
   * @generated from field: optional uint32 bitfield = 9;
   */
  bitfield?: number;
};

/**
 * Describes the message meshtastic.Data.
 * Use `create(DataSchema)` to create a new message.
 */
export const DataSchema: GenMessage<Data> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 4);

/**
 *
 * Waypoint message, used to share arbitrary locations across the mesh
 *
 * @generated from message meshtastic.Waypoint
 */
export type Waypoint = Message<"meshtastic.Waypoint"> & {
  /**
   *
   * Id of the waypoint
   *
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   *
   * latitude_i
   *
   * @generated from field: optional sfixed32 latitude_i = 2;
   */
  latitudeI?: number;

  /**
   *
   * longitude_i
   *
   * @generated from field: optional sfixed32 longitude_i = 3;
   */
  longitudeI?: number;

  /**
   *
   * Time the waypoint is to expire (epoch)
   *
   * @generated from field: uint32 expire = 4;
   */
  expire: number;

  /**
   *
   * If greater than zero, treat the value as a nodenum only allowing them to update the waypoint.
   * If zero, the waypoint is open to be edited by any member of the mesh.
   *
   * @generated from field: uint32 locked_to = 5;
   */
  lockedTo: number;

  /**
   *
   * Name of the waypoint - max 30 chars
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   *
   * Description of the waypoint - max 100 chars
   *
   * @generated from field: string description = 7;
   */
  description: string;

  /**
   *
   * Designator icon for the waypoint in the form of a unicode emoji
   *
   * @generated from field: fixed32 icon = 8;
   */
  icon: number;
};

/**
 * Describes the message meshtastic.Waypoint.
 * Use `create(WaypointSchema)` to create a new message.
 */
export const WaypointSchema: GenMessage<Waypoint> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 5);

/**
 *
 * This message will be proxied over the PhoneAPI for the client to deliver to the MQTT server
 *
 * @generated from message meshtastic.MqttClientProxyMessage
 */
export type MqttClientProxyMessage = Message<"meshtastic.MqttClientProxyMessage"> & {
  /**
   *
   * The MQTT topic this message will be sent /received on
   *
   * @generated from field: string topic = 1;
   */
  topic: string;

  /**
   *
   * The actual service envelope payload or text for mqtt pub / sub
   *
   * @generated from oneof meshtastic.MqttClientProxyMessage.payload_variant
   */
  payloadVariant: {
    /**
     *
     * Bytes
     *
     * @generated from field: bytes data = 2;
     */
    value: Uint8Array;
    case: "data";
  } | {
    /**
     *
     * Text
     *
     * @generated from field: string text = 3;
     */
    value: string;
    case: "text";
  } | { case: undefined; value?: undefined };

  /**
   *
   * Whether the message should be retained (or not)
   *
   * @generated from field: bool retained = 4;
   */
  retained: boolean;
};

/**
 * Describes the message meshtastic.MqttClientProxyMessage.
 * Use `create(MqttClientProxyMessageSchema)` to create a new message.
 */
export const MqttClientProxyMessageSchema: GenMessage<MqttClientProxyMessage> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 6);

/**
 *
 * A packet envelope sent/received over the mesh
 * only payload_variant is sent in the payload portion of the LORA packet.
 * The other fields are either not sent at all, or sent in the special 16 byte LORA header.
 *
 * @generated from message meshtastic.MeshPacket
 */
export type MeshPacket = Message<"meshtastic.MeshPacket"> & {
  /**
   *
   * The sending node number.
   * Note: Our crypto implementation uses this field as well.
   * See [crypto](/docs/overview/encryption) for details.
   *
   * @generated from field: fixed32 from = 1;
   */
  from: number;

  /**
   *
   * The (immediate) destination for this packet
   *
   * @generated from field: fixed32 to = 2;
   */
  to: number;

  /**
   *
   * (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
   * If unset, packet was on the primary channel.
   * A particular node might know only a subset of channels in use on the mesh.
   * Therefore channel_index is inherently a local concept and meaningless to send between nodes.
   * Very briefly, while sending and receiving deep inside the device Router code, this field instead
   * contains the 'channel hash' instead of the index.
   * This 'trick' is only used while the payload_variant is an 'encrypted'.
   *
   * @generated from field: uint32 channel = 3;
   */
  channel: number;

  /**
   * @generated from oneof meshtastic.MeshPacket.payload_variant
   */
  payloadVariant: {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.Data decoded = 4;
     */
    value: Data;
    case: "decoded";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: bytes encrypted = 5;
     */
    value: Uint8Array;
    case: "encrypted";
  } | { case: undefined; value?: undefined };

  /**
   *
   * A unique ID for this packet.
   * Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
   * Otherwise a unique ID for this packet, useful for flooding algorithms.
   * ID only needs to be unique on a _per sender_ basis, and it only
   * needs to be unique for a few minutes (long enough to last for the length of
   * any ACK or the completion of a mesh broadcast flood).
   * Note: Our crypto implementation uses this id as well.
   * See [crypto](/docs/overview/encryption) for details.
   *
   * @generated from field: fixed32 id = 6;
   */
  id: number;

  /**
   *
   * The time this message was received by the esp32 (secs since 1970).
   * Note: this field is _never_ sent on the radio link itself (to save space) Times
   * are typically not sent over the mesh, but they will be added to any Packet
   * (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
   *
   * @generated from field: fixed32 rx_time = 7;
   */
  rxTime: number;

  /**
   *
   * *Never* sent over the radio links.
   * Set during reception to indicate the SNR of this packet.
   * Used to collect statistics on current link quality.
   *
   * @generated from field: float rx_snr = 8;
   */
  rxSnr: number;

  /**
   *
   * If unset treated as zero (no forwarding, send to direct neighbor nodes only)
   * if 1, allow hopping through one node, etc...
   * For our usecase real world topologies probably have a max of about 3.
   * This field is normally placed into a few of bits in the header.
   *
   * @generated from field: uint32 hop_limit = 9;
   */
  hopLimit: number;

  /**
   *
   * This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
   * We would like to receive a ack packet in response.
   * Broadcasts messages treat this flag specially: Since acks for broadcasts would
   * rapidly flood the channel, the normal ack behavior is suppressed.
   * Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
   * If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
   * So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
   * If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
   * Note: This flag is normally sent in a flag bit in the header when sent over the wire
   *
   * @generated from field: bool want_ack = 10;
   */
  wantAck: boolean;

  /**
   *
   * The priority of this message for sending.
   * See MeshPacket.Priority description for more details.
   *
   * @generated from field: meshtastic.MeshPacket.Priority priority = 11;
   */
  priority: MeshPacket_Priority;

  /**
   *
   * rssi of received packet. Only sent to phone for dispay purposes.
   *
   * @generated from field: int32 rx_rssi = 12;
   */
  rxRssi: number;

  /**
   *
   * Describe if this message is delayed
   *
   * @generated from field: meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
   * @deprecated
   */
  delayed: MeshPacket_Delayed;

  /**
   *
   * Describes whether this packet passed via MQTT somewhere along the path it currently took.
   *
   * @generated from field: bool via_mqtt = 14;
   */
  viaMqtt: boolean;

  /**
   *
   * Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
   * When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
   *
   * @generated from field: uint32 hop_start = 15;
   */
  hopStart: number;

  /**
   *
   * Records the public key the packet was encrypted with, if applicable.
   *
   * @generated from field: bytes public_key = 16;
   */
  publicKey: Uint8Array;

  /**
   *
   * Indicates whether the packet was en/decrypted using PKI
   *
   * @generated from field: bool pki_encrypted = 17;
   */
  pkiEncrypted: boolean;

  /**
   *
   * Last byte of the node number of the node that should be used as the next hop in routing.
   * Set by the firmware internally, clients are not supposed to set this.
   *
   * @generated from field: uint32 next_hop = 18;
   */
  nextHop: number;

  /**
   *
   * Last byte of the node number of the node that will relay/relayed this packet.
   * Set by the firmware internally, clients are not supposed to set this.
   *
   * @generated from field: uint32 relay_node = 19;
   */
  relayNode: number;

  /**
   *
   * *Never* sent over the radio links.
   * Timestamp after which this packet may be sent.
   * Set by the firmware internally, clients are not supposed to set this.
   *
   * @generated from field: uint32 tx_after = 20;
   */
  txAfter: number;
};

/**
 * Describes the message meshtastic.MeshPacket.
 * Use `create(MeshPacketSchema)` to create a new message.
 */
export const MeshPacketSchema: GenMessage<MeshPacket> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 7);

/**
 *
 * The priority of this message for sending.
 * Higher priorities are sent first (when managing the transmit queue).
 * This field is never sent over the air, it is only used internally inside of a local device node.
 * API clients (either on the local node or connected directly to the node)
 * can set this parameter if necessary.
 * (values must be <= 127 to keep protobuf field to one byte in size.
 * Detailed background on this field:
 * I noticed a funny side effect of lora being so slow: Usually when making
 * a protocol there isnâ€™t much need to use message priority to change the order
 * of transmission (because interfaces are fairly fast).
 * But for lora where packets can take a few seconds each, it is very important
 * to make sure that critical packets are sent ASAP.
 * In the case of meshtastic that means we want to send protocol acks as soon as possible
 * (to prevent unneeded retransmissions), we want routing messages to be sent next,
 * then messages marked as reliable and finally 'background' packets like periodic position updates.
 * So I bit the bullet and implemented a new (internal - not sent over the air)
 * field in MeshPacket called 'priority'.
 * And the transmission queue in the router object is now a priority queue.
 *
 * @generated from enum meshtastic.MeshPacket.Priority
 */
export enum MeshPacket_Priority {
  /**
   *
   * Treated as Priority.DEFAULT
   *
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: MIN = 1;
   */
  MIN = 1,

  /**
   *
   * Background position updates are sent with very low priority -
   * if the link is super congested they might not go out at all
   *
   * @generated from enum value: BACKGROUND = 10;
   */
  BACKGROUND = 10,

  /**
   *
   * This priority is used for most messages that don't have a priority set
   *
   * @generated from enum value: DEFAULT = 64;
   */
  DEFAULT = 64,

  /**
   *
   * If priority is unset but the message is marked as want_ack,
   * assume it is important and use a slightly higher priority
   *
   * @generated from enum value: RELIABLE = 70;
   */
  RELIABLE = 70,

  /**
   *
   * If priority is unset but the packet is a response to a request, we want it to get there relatively quickly.
   * Furthermore, responses stop relaying packets directed to a node early.
   *
   * @generated from enum value: RESPONSE = 80;
   */
  RESPONSE = 80,

  /**
   *
   * Higher priority for specific message types (portnums) to distinguish between other reliable packets.
   *
   * @generated from enum value: HIGH = 100;
   */
  HIGH = 100,

  /**
   *
   * Higher priority alert message used for critical alerts which take priority over other reliable packets.
   *
   * @generated from enum value: ALERT = 110;
   */
  ALERT = 110,

  /**
   *
   * Ack/naks are sent with very high priority to ensure that retransmission
   * stops as soon as possible
   *
   * @generated from enum value: ACK = 120;
   */
  ACK = 120,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: MAX = 127;
   */
  MAX = 127,
}

/**
 * Describes the enum meshtastic.MeshPacket.Priority.
 */
export const MeshPacket_PrioritySchema: GenEnum<MeshPacket_Priority> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 7, 0);

/**
 *
 * Identify if this is a delayed packet
 *
 * @generated from enum meshtastic.MeshPacket.Delayed
 */
export enum MeshPacket_Delayed {
  /**
   *
   * If unset, the message is being sent in real time.
   *
   * @generated from enum value: NO_DELAY = 0;
   */
  NO_DELAY = 0,

  /**
   *
   * The message is delayed and was originally a broadcast
   *
   * @generated from enum value: DELAYED_BROADCAST = 1;
   */
  DELAYED_BROADCAST = 1,

  /**
   *
   * The message is delayed and was originally a direct message
   *
   * @generated from enum value: DELAYED_DIRECT = 2;
   */
  DELAYED_DIRECT = 2,
}

/**
 * Describes the enum meshtastic.MeshPacket.Delayed.
 */
export const MeshPacket_DelayedSchema: GenEnum<MeshPacket_Delayed> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 7, 1);

/**
 *
 * The bluetooth to device link:
 * Old BTLE protocol docs from TODO, merge in above and make real docs...
 * use protocol buffers, and NanoPB
 * messages from device to phone:
 * POSITION_UPDATE (..., time)
 * TEXT_RECEIVED(from, text, time)
 * OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
 * messages from phone to device:
 * SET_MYID(id, human readable long, human readable short) (send down the unique ID
 * string used for this node, a human readable string shown for that id, and a very
 * short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
 * (for signal messages or other applications) SEND_TEXT(dest, text) Get all
 * nodes() (returns list of nodes, with full info, last time seen, loc, battery
 * level etc) SET_CONFIG (switches device to a new set of radio params and
 * preshared key, drops all existing nodes, force our node to rejoin this new group)
 * Full information about a node on the mesh
 *
 * @generated from message meshtastic.NodeInfo
 */
export type NodeInfo = Message<"meshtastic.NodeInfo"> & {
  /**
   *
   * The node number
   *
   * @generated from field: uint32 num = 1;
   */
  num: number;

  /**
   *
   * The user info for this node
   *
   * @generated from field: meshtastic.User user = 2;
   */
  user?: User;

  /**
   *
   * This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
   * Position.time now indicates the last time we received a POSITION from that node.
   *
   * @generated from field: meshtastic.Position position = 3;
   */
  position?: Position;

  /**
   *
   * Returns the Signal-to-noise ratio (SNR) of the last received message,
   * as measured by the receiver. Return SNR of the last received message in dB
   *
   * @generated from field: float snr = 4;
   */
  snr: number;

  /**
   *
   * Set to indicate the last time we received a packet from this node
   *
   * @generated from field: fixed32 last_heard = 5;
   */
  lastHeard: number;

  /**
   *
   * The latest device metrics for the node.
   *
   * @generated from field: meshtastic.DeviceMetrics device_metrics = 6;
   */
  deviceMetrics?: DeviceMetrics;

  /**
   *
   * local channel index we heard that node on. Only populated if its not the default channel.
   *
   * @generated from field: uint32 channel = 7;
   */
  channel: number;

  /**
   *
   * True if we witnessed the node over MQTT instead of LoRA transport
   *
   * @generated from field: bool via_mqtt = 8;
   */
  viaMqtt: boolean;

  /**
   *
   * Number of hops away from us this node is (0 if direct neighbor)
   *
   * @generated from field: optional uint32 hops_away = 9;
   */
  hopsAway?: number;

  /**
   *
   * True if node is in our favorites list
   * Persists between NodeDB internal clean ups
   *
   * @generated from field: bool is_favorite = 10;
   */
  isFavorite: boolean;

  /**
   *
   * True if node is in our ignored list
   * Persists between NodeDB internal clean ups
   *
   * @generated from field: bool is_ignored = 11;
   */
  isIgnored: boolean;
};

/**
 * Describes the message meshtastic.NodeInfo.
 * Use `create(NodeInfoSchema)` to create a new message.
 */
export const NodeInfoSchema: GenMessage<NodeInfo> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 8);

/**
 *
 * Unique local debugging info for this node
 * Note: we don't include position or the user info, because that will come in the
 * Sent to the phone in response to WantNodes.
 *
 * @generated from message meshtastic.MyNodeInfo
 */
export type MyNodeInfo = Message<"meshtastic.MyNodeInfo"> & {
  /**
   *
   * Tells the phone what our node number is, default starting value is
   * lowbyte of macaddr, but it will be fixed if that is already in use
   *
   * @generated from field: uint32 my_node_num = 1;
   */
  myNodeNum: number;

  /**
   *
   * The total number of reboots this node has ever encountered
   * (well - since the last time we discarded preferences)
   *
   * @generated from field: uint32 reboot_count = 8;
   */
  rebootCount: number;

  /**
   *
   * The minimum app version that can talk to this device.
   * Phone/PC apps should compare this to their build number and if too low tell the user they must update their app
   *
   * @generated from field: uint32 min_app_version = 11;
   */
  minAppVersion: number;

  /**
   *
   * Unique hardware identifier for this device
   *
   * @generated from field: bytes device_id = 12;
   */
  deviceId: Uint8Array;

  /**
   *
   * The PlatformIO environment used to build this firmware
   *
   * @generated from field: string pio_env = 13;
   */
  pioEnv: string;
};

/**
 * Describes the message meshtastic.MyNodeInfo.
 * Use `create(MyNodeInfoSchema)` to create a new message.
 */
export const MyNodeInfoSchema: GenMessage<MyNodeInfo> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 9);

/**
 *
 * Debug output from the device.
 * To minimize the size of records inside the device code, if a time/source/level is not set
 * on the message it is assumed to be a continuation of the previously sent message.
 * This allows the device code to use fixed maxlen 64 byte strings for messages,
 * and then extend as needed by emitting multiple records.
 *
 * @generated from message meshtastic.LogRecord
 */
export type LogRecord = Message<"meshtastic.LogRecord"> & {
  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from field: string message = 1;
   */
  message: string;

  /**
   *
   * Seconds since 1970 - or 0 for unknown/unset
   *
   * @generated from field: fixed32 time = 2;
   */
  time: number;

  /**
   *
   * Usually based on thread name - if known
   *
   * @generated from field: string source = 3;
   */
  source: string;

  /**
   *
   * Not yet set
   *
   * @generated from field: meshtastic.LogRecord.Level level = 4;
   */
  level: LogRecord_Level;
};

/**
 * Describes the message meshtastic.LogRecord.
 * Use `create(LogRecordSchema)` to create a new message.
 */
export const LogRecordSchema: GenMessage<LogRecord> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 10);

/**
 *
 * Log levels, chosen to match python logging conventions.
 *
 * @generated from enum meshtastic.LogRecord.Level
 */
export enum LogRecord_Level {
  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from enum value: CRITICAL = 50;
   */
  CRITICAL = 50,

  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from enum value: ERROR = 40;
   */
  ERROR = 40,

  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from enum value: WARNING = 30;
   */
  WARNING = 30,

  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from enum value: INFO = 20;
   */
  INFO = 20,

  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from enum value: DEBUG = 10;
   */
  DEBUG = 10,

  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from enum value: TRACE = 5;
   */
  TRACE = 5,
}

/**
 * Describes the enum meshtastic.LogRecord.Level.
 */
export const LogRecord_LevelSchema: GenEnum<LogRecord_Level> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 10, 0);

/**
 * @generated from message meshtastic.QueueStatus
 */
export type QueueStatus = Message<"meshtastic.QueueStatus"> & {
  /**
   * Last attempt to queue status, ErrorCode 
   *
   * @generated from field: int32 res = 1;
   */
  res: number;

  /**
   * Free entries in the outgoing queue 
   *
   * @generated from field: uint32 free = 2;
   */
  free: number;

  /**
   * Maximum entries in the outgoing queue 
   *
   * @generated from field: uint32 maxlen = 3;
   */
  maxlen: number;

  /**
   * What was mesh packet id that generated this response? 
   *
   * @generated from field: uint32 mesh_packet_id = 4;
   */
  meshPacketId: number;
};

/**
 * Describes the message meshtastic.QueueStatus.
 * Use `create(QueueStatusSchema)` to create a new message.
 */
export const QueueStatusSchema: GenMessage<QueueStatus> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 11);

/**
 *
 * Packets from the radio to the phone will appear on the fromRadio characteristic.
 * It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
 * It will sit in that descriptor until consumed by the phone,
 * at which point the next item in the FIFO will be populated.
 *
 * @generated from message meshtastic.FromRadio
 */
export type FromRadio = Message<"meshtastic.FromRadio"> & {
  /**
   *
   * The packet id, used to allow the phone to request missing read packets from the FIFO,
   * see our bluetooth docs
   *
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from oneof meshtastic.FromRadio.payload_variant
   */
  payloadVariant: {
    /**
     *
     * Log levels, chosen to match python logging conventions.
     *
     * @generated from field: meshtastic.MeshPacket packet = 2;
     */
    value: MeshPacket;
    case: "packet";
  } | {
    /**
     *
     * Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
     * NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
     *
     * @generated from field: meshtastic.MyNodeInfo my_info = 3;
     */
    value: MyNodeInfo;
    case: "myInfo";
  } | {
    /**
     *
     * One packet is sent for each node in the on radio DB
     * starts over with the first node in our DB
     *
     * @generated from field: meshtastic.NodeInfo node_info = 4;
     */
    value: NodeInfo;
    case: "nodeInfo";
  } | {
    /**
     *
     * Include a part of the config (was: RadioConfig radio)
     *
     * @generated from field: meshtastic.Config config = 5;
     */
    value: Config;
    case: "config";
  } | {
    /**
     *
     * Set to send debug console output over our protobuf stream
     *
     * @generated from field: meshtastic.LogRecord log_record = 6;
     */
    value: LogRecord;
    case: "logRecord";
  } | {
    /**
     *
     * Sent as true once the device has finished sending all of the responses to want_config
     * recipient should check if this ID matches our original request nonce, if
     * not, it means your config responses haven't started yet.
     * NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
     *
     * @generated from field: uint32 config_complete_id = 7;
     */
    value: number;
    case: "configCompleteId";
  } | {
    /**
     *
     * Sent to tell clients the radio has just rebooted.
     * Set to true if present.
     * Not used on all transports, currently just used for the serial console.
     * NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
     *
     * @generated from field: bool rebooted = 8;
     */
    value: boolean;
    case: "rebooted";
  } | {
    /**
     *
     * Include module config
     *
     * @generated from field: meshtastic.ModuleConfig moduleConfig = 9;
     */
    value: ModuleConfig;
    case: "moduleConfig";
  } | {
    /**
     *
     * One packet is sent for each channel
     *
     * @generated from field: meshtastic.Channel channel = 10;
     */
    value: Channel;
    case: "channel";
  } | {
    /**
     *
     * Queue status info
     *
     * @generated from field: meshtastic.QueueStatus queueStatus = 11;
     */
    value: QueueStatus;
    case: "queueStatus";
  } | {
    /**
     *
     * File Transfer Chunk
     *
     * @generated from field: meshtastic.XModem xmodemPacket = 12;
     */
    value: XModem;
    case: "xmodemPacket";
  } | {
    /**
     *
     * Device metadata message
     *
     * @generated from field: meshtastic.DeviceMetadata metadata = 13;
     */
    value: DeviceMetadata;
    case: "metadata";
  } | {
    /**
     *
     * MQTT Client Proxy Message (device sending to client / phone for publishing to MQTT)
     *
     * @generated from field: meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
     */
    value: MqttClientProxyMessage;
    case: "mqttClientProxyMessage";
  } | {
    /**
     *
     * File system manifest messages
     *
     * @generated from field: meshtastic.FileInfo fileInfo = 15;
     */
    value: FileInfo;
    case: "fileInfo";
  } | {
    /**
     *
     * Notification message to the client
     *
     * @generated from field: meshtastic.ClientNotification clientNotification = 16;
     */
    value: ClientNotification;
    case: "clientNotification";
  } | {
    /**
     *
     * Persistent data for device-ui
     *
     * @generated from field: meshtastic.DeviceUIConfig deviceuiConfig = 17;
     */
    value: DeviceUIConfig;
    case: "deviceuiConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message meshtastic.FromRadio.
 * Use `create(FromRadioSchema)` to create a new message.
 */
export const FromRadioSchema: GenMessage<FromRadio> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 12);

/**
 *
 * A notification message from the device to the client
 * To be used for important messages that should to be displayed to the user
 * in the form of push notifications or validation messages when saving
 * invalid configuration.
 *
 * @generated from message meshtastic.ClientNotification
 */
export type ClientNotification = Message<"meshtastic.ClientNotification"> & {
  /**
   *
   * The id of the packet we're notifying in response to
   *
   * @generated from field: optional uint32 reply_id = 1;
   */
  replyId?: number;

  /**
   *
   * Seconds since 1970 - or 0 for unknown/unset
   *
   * @generated from field: fixed32 time = 2;
   */
  time: number;

  /**
   *
   * The level type of notification
   *
   * @generated from field: meshtastic.LogRecord.Level level = 3;
   */
  level: LogRecord_Level;

  /**
   *
   * The message body of the notification
   *
   * @generated from field: string message = 4;
   */
  message: string;
};

/**
 * Describes the message meshtastic.ClientNotification.
 * Use `create(ClientNotificationSchema)` to create a new message.
 */
export const ClientNotificationSchema: GenMessage<ClientNotification> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 13);

/**
 *
 * Individual File info for the device
 *
 * @generated from message meshtastic.FileInfo
 */
export type FileInfo = Message<"meshtastic.FileInfo"> & {
  /**
   *
   * The fully qualified path of the file
   *
   * @generated from field: string file_name = 1;
   */
  fileName: string;

  /**
   *
   * The size of the file in bytes
   *
   * @generated from field: uint32 size_bytes = 2;
   */
  sizeBytes: number;
};

/**
 * Describes the message meshtastic.FileInfo.
 * Use `create(FileInfoSchema)` to create a new message.
 */
export const FileInfoSchema: GenMessage<FileInfo> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 14);

/**
 *
 * Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
 * Once the write completes the phone can assume it is handled.
 *
 * @generated from message meshtastic.ToRadio
 */
export type ToRadio = Message<"meshtastic.ToRadio"> & {
  /**
   *
   * Log levels, chosen to match python logging conventions.
   *
   * @generated from oneof meshtastic.ToRadio.payload_variant
   */
  payloadVariant: {
    /**
     *
     * Send this packet on the mesh
     *
     * @generated from field: meshtastic.MeshPacket packet = 1;
     */
    value: MeshPacket;
    case: "packet";
  } | {
    /**
     *
     * Phone wants radio to send full node db to the phone, This is
     * typically the first packet sent to the radio when the phone gets a
     * bluetooth connection. The radio will respond by sending back a
     * MyNodeInfo, a owner, a radio config and a series of
     * FromRadio.node_infos, and config_complete
     * the integer you write into this field will be reported back in the
     * config_complete_id response this allows clients to never be confused by
     * a stale old partially sent config.
     *
     * @generated from field: uint32 want_config_id = 3;
     */
    value: number;
    case: "wantConfigId";
  } | {
    /**
     *
     * Tell API server we are disconnecting now.
     * This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
     * (Sending this message is optional for clients)
     *
     * @generated from field: bool disconnect = 4;
     */
    value: boolean;
    case: "disconnect";
  } | {
    /**
     * @generated from field: meshtastic.XModem xmodemPacket = 5;
     */
    value: XModem;
    case: "xmodemPacket";
  } | {
    /**
     *
     * MQTT Client Proxy Message (for client / phone subscribed to MQTT sending to device)
     *
     * @generated from field: meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
     */
    value: MqttClientProxyMessage;
    case: "mqttClientProxyMessage";
  } | {
    /**
     *
     * Heartbeat message (used to keep the device connection awake on serial)
     *
     * @generated from field: meshtastic.Heartbeat heartbeat = 7;
     */
    value: Heartbeat;
    case: "heartbeat";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message meshtastic.ToRadio.
 * Use `create(ToRadioSchema)` to create a new message.
 */
export const ToRadioSchema: GenMessage<ToRadio> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 15);

/**
 *
 * Compressed message payload
 *
 * @generated from message meshtastic.Compressed
 */
export type Compressed = Message<"meshtastic.Compressed"> & {
  /**
   *
   * PortNum to determine the how to handle the compressed payload.
   *
   * @generated from field: meshtastic.PortNum portnum = 1;
   */
  portnum: PortNum;

  /**
   *
   * Compressed data.
   *
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;
};

/**
 * Describes the message meshtastic.Compressed.
 * Use `create(CompressedSchema)` to create a new message.
 */
export const CompressedSchema: GenMessage<Compressed> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 16);

/**
 *
 * Full info on edges for a single node
 *
 * @generated from message meshtastic.NeighborInfo
 */
export type NeighborInfo = Message<"meshtastic.NeighborInfo"> & {
  /**
   *
   * The node ID of the node sending info on its neighbors
   *
   * @generated from field: uint32 node_id = 1;
   */
  nodeId: number;

  /**
   *
   * Field to pass neighbor info for the next sending cycle
   *
   * @generated from field: uint32 last_sent_by_id = 2;
   */
  lastSentById: number;

  /**
   *
   * Broadcast interval of the represented node (in seconds)
   *
   * @generated from field: uint32 node_broadcast_interval_secs = 3;
   */
  nodeBroadcastIntervalSecs: number;

  /**
   *
   * The list of out edges from this node
   *
   * @generated from field: repeated meshtastic.Neighbor neighbors = 4;
   */
  neighbors: Neighbor[];
};

/**
 * Describes the message meshtastic.NeighborInfo.
 * Use `create(NeighborInfoSchema)` to create a new message.
 */
export const NeighborInfoSchema: GenMessage<NeighborInfo> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 17);

/**
 *
 * A single edge in the mesh
 *
 * @generated from message meshtastic.Neighbor
 */
export type Neighbor = Message<"meshtastic.Neighbor"> & {
  /**
   *
   * Node ID of neighbor
   *
   * @generated from field: uint32 node_id = 1;
   */
  nodeId: number;

  /**
   *
   * SNR of last heard message
   *
   * @generated from field: float snr = 2;
   */
  snr: number;

  /**
   *
   * Reception time (in secs since 1970) of last message that was last sent by this ID.
   * Note: this is for local storage only and will not be sent out over the mesh.
   *
   * @generated from field: fixed32 last_rx_time = 3;
   */
  lastRxTime: number;

  /**
   *
   * Broadcast interval of this neighbor (in seconds).
   * Note: this is for local storage only and will not be sent out over the mesh.
   *
   * @generated from field: uint32 node_broadcast_interval_secs = 4;
   */
  nodeBroadcastIntervalSecs: number;
};

/**
 * Describes the message meshtastic.Neighbor.
 * Use `create(NeighborSchema)` to create a new message.
 */
export const NeighborSchema: GenMessage<Neighbor> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 18);

/**
 *
 * Device metadata response
 *
 * @generated from message meshtastic.DeviceMetadata
 */
export type DeviceMetadata = Message<"meshtastic.DeviceMetadata"> & {
  /**
   *
   * Device firmware version string
   *
   * @generated from field: string firmware_version = 1;
   */
  firmwareVersion: string;

  /**
   *
   * Device state version
   *
   * @generated from field: uint32 device_state_version = 2;
   */
  deviceStateVersion: number;

  /**
   *
   * Indicates whether the device can shutdown CPU natively or via power management chip
   *
   * @generated from field: bool canShutdown = 3;
   */
  canShutdown: boolean;

  /**
   *
   * Indicates that the device has native wifi capability
   *
   * @generated from field: bool hasWifi = 4;
   */
  hasWifi: boolean;

  /**
   *
   * Indicates that the device has native bluetooth capability
   *
   * @generated from field: bool hasBluetooth = 5;
   */
  hasBluetooth: boolean;

  /**
   *
   * Indicates that the device has an ethernet peripheral
   *
   * @generated from field: bool hasEthernet = 6;
   */
  hasEthernet: boolean;

  /**
   *
   * Indicates that the device's role in the mesh
   *
   * @generated from field: meshtastic.Config.DeviceConfig.Role role = 7;
   */
  role: Config_DeviceConfig_Role;

  /**
   *
   * Indicates the device's current enabled position flags
   *
   * @generated from field: uint32 position_flags = 8;
   */
  positionFlags: number;

  /**
   *
   * Device hardware model
   *
   * @generated from field: meshtastic.HardwareModel hw_model = 9;
   */
  hwModel: HardwareModel;

  /**
   *
   * Has Remote Hardware enabled
   *
   * @generated from field: bool hasRemoteHardware = 10;
   */
  hasRemoteHardware: boolean;

  /**
   *
   * Has PKC capabilities
   *
   * @generated from field: bool hasPKC = 11;
   */
  hasPKC: boolean;

  /**
   *
   * Bit field of boolean for excluded modules
   * (bitwise OR of ExcludedModules)
   *
   * @generated from field: uint32 excluded_modules = 12;
   */
  excludedModules: number;
};

/**
 * Describes the message meshtastic.DeviceMetadata.
 * Use `create(DeviceMetadataSchema)` to create a new message.
 */
export const DeviceMetadataSchema: GenMessage<DeviceMetadata> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 19);

/**
 *
 * A heartbeat message is sent to the node from the client to keep the connection alive.
 * This is currently only needed to keep serial connections alive, but can be used by any PhoneAPI.
 *
 * @generated from message meshtastic.Heartbeat
 */
export type Heartbeat = Message<"meshtastic.Heartbeat"> & {
};

/**
 * Describes the message meshtastic.Heartbeat.
 * Use `create(HeartbeatSchema)` to create a new message.
 */
export const HeartbeatSchema: GenMessage<Heartbeat> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 20);

/**
 *
 * RemoteHardwarePins associated with a node
 *
 * @generated from message meshtastic.NodeRemoteHardwarePin
 */
export type NodeRemoteHardwarePin = Message<"meshtastic.NodeRemoteHardwarePin"> & {
  /**
   *
   * The node_num exposing the available gpio pin
   *
   * @generated from field: uint32 node_num = 1;
   */
  nodeNum: number;

  /**
   *
   * The the available gpio pin for usage with RemoteHardware module
   *
   * @generated from field: meshtastic.RemoteHardwarePin pin = 2;
   */
  pin?: RemoteHardwarePin;
};

/**
 * Describes the message meshtastic.NodeRemoteHardwarePin.
 * Use `create(NodeRemoteHardwarePinSchema)` to create a new message.
 */
export const NodeRemoteHardwarePinSchema: GenMessage<NodeRemoteHardwarePin> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 21);

/**
 * @generated from message meshtastic.ChunkedPayload
 */
export type ChunkedPayload = Message<"meshtastic.ChunkedPayload"> & {
  /**
   *
   * The ID of the entire payload
   *
   * @generated from field: uint32 payload_id = 1;
   */
  payloadId: number;

  /**
   *
   * The total number of chunks in the payload
   *
   * @generated from field: uint32 chunk_count = 2;
   */
  chunkCount: number;

  /**
   *
   * The current chunk index in the total
   *
   * @generated from field: uint32 chunk_index = 3;
   */
  chunkIndex: number;

  /**
   *
   * The binary data of the current chunk
   *
   * @generated from field: bytes payload_chunk = 4;
   */
  payloadChunk: Uint8Array;
};

/**
 * Describes the message meshtastic.ChunkedPayload.
 * Use `create(ChunkedPayloadSchema)` to create a new message.
 */
export const ChunkedPayloadSchema: GenMessage<ChunkedPayload> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 22);

/**
 *
 * Wrapper message for broken repeated oneof support
 *
 * @generated from message meshtastic.resend_chunks
 */
export type resend_chunks = Message<"meshtastic.resend_chunks"> & {
  /**
   * @generated from field: repeated uint32 chunks = 1;
   */
  chunks: number[];
};

/**
 * Describes the message meshtastic.resend_chunks.
 * Use `create(resend_chunksSchema)` to create a new message.
 */
export const resend_chunksSchema: GenMessage<resend_chunks> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 23);

/**
 *
 * Responses to a ChunkedPayload request
 *
 * @generated from message meshtastic.ChunkedPayloadResponse
 */
export type ChunkedPayloadResponse = Message<"meshtastic.ChunkedPayloadResponse"> & {
  /**
   *
   * The ID of the entire payload
   *
   * @generated from field: uint32 payload_id = 1;
   */
  payloadId: number;

  /**
   * @generated from oneof meshtastic.ChunkedPayloadResponse.payload_variant
   */
  payloadVariant: {
    /**
     *
     * Request to transfer chunked payload
     *
     * @generated from field: bool request_transfer = 2;
     */
    value: boolean;
    case: "requestTransfer";
  } | {
    /**
     *
     * Accept the transfer chunked payload
     *
     * @generated from field: bool accept_transfer = 3;
     */
    value: boolean;
    case: "acceptTransfer";
  } | {
    /**
     *
     * Request missing indexes in the chunked payload
     *
     * @generated from field: meshtastic.resend_chunks resend_chunks = 4;
     */
    value: resend_chunks;
    case: "resendChunks";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message meshtastic.ChunkedPayloadResponse.
 * Use `create(ChunkedPayloadResponseSchema)` to create a new message.
 */
export const ChunkedPayloadResponseSchema: GenMessage<ChunkedPayloadResponse> = /*@__PURE__*/
  messageDesc(file_meshtastic_mesh, 24);

/**
 *
 * Note: these enum names must EXACTLY match the string used in the device
 * bin/build-all.sh script.
 * Because they will be used to find firmware filenames in the android app for OTA updates.
 * To match the old style filenames, _ is converted to -, p is converted to .
 *
 * @generated from enum meshtastic.HardwareModel
 */
export enum HardwareModel {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TLORA_V2 = 1;
   */
  TLORA_V2 = 1,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TLORA_V1 = 2;
   */
  TLORA_V1 = 2,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TLORA_V2_1_1P6 = 3;
   */
  TLORA_V2_1_1P6 = 3,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TBEAM = 4;
   */
  TBEAM = 4,

  /**
   *
   * The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13
   * (see HELTEC_V2 for the new version).
   *
   * @generated from enum value: HELTEC_V2_0 = 5;
   */
  HELTEC_V2_0 = 5,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TBEAM_V0P7 = 6;
   */
  TBEAM_V0P7 = 6,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: T_ECHO = 7;
   */
  T_ECHO = 7,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TLORA_V1_1P3 = 8;
   */
  TLORA_V1_1P3 = 8,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: RAK4631 = 9;
   */
  RAK4631 = 9,

  /**
   *
   * The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.
   * Sadly they did not update anything on the silkscreen to identify this board
   *
   * @generated from enum value: HELTEC_V2_1 = 10;
   */
  HELTEC_V2_1 = 10,

  /**
   *
   * Ancient heltec WiFi_Lora_32 board
   *
   * @generated from enum value: HELTEC_V1 = 11;
   */
  HELTEC_V1 = 11,

  /**
   *
   * New T-BEAM with ESP32-S3 CPU
   *
   * @generated from enum value: LILYGO_TBEAM_S3_CORE = 12;
   */
  LILYGO_TBEAM_S3_CORE = 12,

  /**
   *
   * RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/
   *
   * @generated from enum value: RAK11200 = 13;
   */
  RAK11200 = 13,

  /**
   *
   * B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano
   *
   * @generated from enum value: NANO_G1 = 14;
   */
  NANO_G1 = 14,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TLORA_V2_1_1P8 = 15;
   */
  TLORA_V2_1_1P8 = 15,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: TLORA_T3_S3 = 16;
   */
  TLORA_T3_S3 = 16,

  /**
   *
   * B&Q Consulting Nano G1 Explorer: https://wiki.uniteng.com/en/meshtastic/nano-g1-explorer
   *
   * @generated from enum value: NANO_G1_EXPLORER = 17;
   */
  NANO_G1_EXPLORER = 17,

  /**
   *
   * B&Q Consulting Nano G2 Ultra: https://wiki.uniteng.com/en/meshtastic/nano-g2-ultra
   *
   * @generated from enum value: NANO_G2_ULTRA = 18;
   */
  NANO_G2_ULTRA = 18,

  /**
   *
   * LoRAType device: https://loratype.org/
   *
   * @generated from enum value: LORA_TYPE = 19;
   */
  LORA_TYPE = 19,

  /**
   *
   * wiphone https://www.wiphone.io/
   *
   * @generated from enum value: WIPHONE = 20;
   */
  WIPHONE = 20,

  /**
   *
   * WIO Tracker WM1110 family from Seeed Studio. Includes wio-1110-tracker and wio-1110-sdk
   *
   * @generated from enum value: WIO_WM1110 = 21;
   */
  WIO_WM1110 = 21,

  /**
   *
   * RAK2560 Solar base station based on RAK4630
   *
   * @generated from enum value: RAK2560 = 22;
   */
  RAK2560 = 22,

  /**
   *
   * Heltec HRU-3601: https://heltec.org/project/hru-3601/
   *
   * @generated from enum value: HELTEC_HRU_3601 = 23;
   */
  HELTEC_HRU_3601 = 23,

  /**
   *
   * Heltec Wireless Bridge
   *
   * @generated from enum value: HELTEC_WIRELESS_BRIDGE = 24;
   */
  HELTEC_WIRELESS_BRIDGE = 24,

  /**
   *
   * B&Q Consulting Station Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:station
   *
   * @generated from enum value: STATION_G1 = 25;
   */
  STATION_G1 = 25,

  /**
   *
   * RAK11310 (RP2040 + SX1262)
   *
   * @generated from enum value: RAK11310 = 26;
   */
  RAK11310 = 26,

  /**
   *
   * Makerfabs SenseLoRA Receiver (RP2040 + RFM96)
   *
   * @generated from enum value: SENSELORA_RP2040 = 27;
   */
  SENSELORA_RP2040 = 27,

  /**
   *
   * Makerfabs SenseLoRA Industrial Monitor (ESP32-S3 + RFM96)
   *
   * @generated from enum value: SENSELORA_S3 = 28;
   */
  SENSELORA_S3 = 28,

  /**
   *
   * Canary Radio Company - CanaryOne: https://canaryradio.io/products/canaryone
   *
   * @generated from enum value: CANARYONE = 29;
   */
  CANARYONE = 29,

  /**
   *
   * Waveshare RP2040 LoRa - https://www.waveshare.com/rp2040-lora.htm
   *
   * @generated from enum value: RP2040_LORA = 30;
   */
  RP2040_LORA = 30,

  /**
   *
   * B&Q Consulting Station G2: https://wiki.uniteng.com/en/meshtastic/station-g2
   *
   * @generated from enum value: STATION_G2 = 31;
   */
  STATION_G2 = 31,

  /**
   *
   * ---------------------------------------------------------------------------
   * Less common/prototype boards listed here (needs one more byte over the air)
   * ---------------------------------------------------------------------------
   *
   * @generated from enum value: LORA_RELAY_V1 = 32;
   */
  LORA_RELAY_V1 = 32,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: NRF52840DK = 33;
   */
  NRF52840DK = 33,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: PPR = 34;
   */
  PPR = 34,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: GENIEBLOCKS = 35;
   */
  GENIEBLOCKS = 35,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: NRF52_UNKNOWN = 36;
   */
  NRF52_UNKNOWN = 36,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: PORTDUINO = 37;
   */
  PORTDUINO = 37,

  /**
   *
   * The simulator built into the android app
   *
   * @generated from enum value: ANDROID_SIM = 38;
   */
  ANDROID_SIM = 38,

  /**
   *
   * Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics
   *
   * @generated from enum value: DIY_V1 = 39;
   */
  DIY_V1 = 39,

  /**
   *
   * nRF52840 Dongle : https://www.nordicsemi.com/Products/Development-hardware/nrf52840-dongle/
   *
   * @generated from enum value: NRF52840_PCA10059 = 40;
   */
  NRF52840_PCA10059 = 40,

  /**
   *
   * Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3
   *
   * @generated from enum value: DR_DEV = 41;
   */
  DR_DEV = 41,

  /**
   *
   * M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
   *
   * @generated from enum value: M5STACK = 42;
   */
  M5STACK = 42,

  /**
   *
   * New Heltec LoRA32 with ESP32-S3 CPU
   *
   * @generated from enum value: HELTEC_V3 = 43;
   */
  HELTEC_V3 = 43,

  /**
   *
   * New Heltec Wireless Stick Lite with ESP32-S3 CPU
   *
   * @generated from enum value: HELTEC_WSL_V3 = 44;
   */
  HELTEC_WSL_V3 = 44,

  /**
   *
   * New BETAFPV ELRS Micro TX Module 2.4G with ESP32 CPU
   *
   * @generated from enum value: BETAFPV_2400_TX = 45;
   */
  BETAFPV_2400_TX = 45,

  /**
   *
   * BetaFPV ExpressLRS "Nano" TX Module 900MHz with ESP32 CPU
   *
   * @generated from enum value: BETAFPV_900_NANO_TX = 46;
   */
  BETAFPV_900_NANO_TX = 46,

  /**
   *
   * Raspberry Pi Pico (W) with Waveshare SX1262 LoRa Node Module
   *
   * @generated from enum value: RPI_PICO = 47;
   */
  RPI_PICO = 47,

  /**
   *
   * Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
   * Newer V1.1, version is written on the PCB near the display.
   *
   * @generated from enum value: HELTEC_WIRELESS_TRACKER = 48;
   */
  HELTEC_WIRELESS_TRACKER = 48,

  /**
   *
   * Heltec Wireless Paper with ESP32-S3 CPU and E-Ink display
   *
   * @generated from enum value: HELTEC_WIRELESS_PAPER = 49;
   */
  HELTEC_WIRELESS_PAPER = 49,

  /**
   *
   * LilyGo T-Deck with ESP32-S3 CPU, Keyboard and IPS display
   *
   * @generated from enum value: T_DECK = 50;
   */
  T_DECK = 50,

  /**
   *
   * LilyGo T-Watch S3 with ESP32-S3 CPU and IPS display
   *
   * @generated from enum value: T_WATCH_S3 = 51;
   */
  T_WATCH_S3 = 51,

  /**
   *
   * Bobricius Picomputer with ESP32-S3 CPU, Keyboard and IPS display
   *
   * @generated from enum value: PICOMPUTER_S3 = 52;
   */
  PICOMPUTER_S3 = 52,

  /**
   *
   * Heltec HT-CT62 with ESP32-C3 CPU and SX1262 LoRa
   *
   * @generated from enum value: HELTEC_HT62 = 53;
   */
  HELTEC_HT62 = 53,

  /**
   *
   * EBYTE SPI LoRa module and ESP32-S3
   *
   * @generated from enum value: EBYTE_ESP32_S3 = 54;
   */
  EBYTE_ESP32_S3 = 54,

  /**
   *
   * Waveshare ESP32-S3-PICO with PICO LoRa HAT and 2.9inch e-Ink
   *
   * @generated from enum value: ESP32_S3_PICO = 55;
   */
  ESP32_S3_PICO = 55,

  /**
   *
   * CircuitMess Chatter 2 LLCC68 Lora Module and ESP32 Wroom
   * Lora module can be swapped out for a Heltec RA-62 which is "almost" pin compatible
   * with one cut and one jumper Meshtastic works
   *
   * @generated from enum value: CHATTER_2 = 56;
   */
  CHATTER_2 = 56,

  /**
   *
   * Heltec Wireless Paper, With ESP32-S3 CPU and E-Ink display
   * Older "V1.0" Variant, has no "version sticker"
   * E-Ink model is DEPG0213BNS800
   * Tab on the screen protector is RED
   * Flex connector marking is FPC-7528B
   *
   * @generated from enum value: HELTEC_WIRELESS_PAPER_V1_0 = 57;
   */
  HELTEC_WIRELESS_PAPER_V1_0 = 57,

  /**
   *
   * Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
   * Older "V1.0" Variant
   *
   * @generated from enum value: HELTEC_WIRELESS_TRACKER_V1_0 = 58;
   */
  HELTEC_WIRELESS_TRACKER_V1_0 = 58,

  /**
   *
   * unPhone with ESP32-S3, TFT touchscreen,  LSM6DS3TR-C accelerometer and gyroscope
   *
   * @generated from enum value: UNPHONE = 59;
   */
  UNPHONE = 59,

  /**
   *
   * Teledatics TD-LORAC NRF52840 based M.2 LoRA module
   * Compatible with the TD-WRLS development board
   *
   * @generated from enum value: TD_LORAC = 60;
   */
  TD_LORAC = 60,

  /**
   *
   * CDEBYTE EoRa-S3 board using their own MM modules, clone of LILYGO T3S3
   *
   * @generated from enum value: CDEBYTE_EORA_S3 = 61;
   */
  CDEBYTE_EORA_S3 = 61,

  /**
   *
   * TWC_MESH_V4
   * Adafruit NRF52840 feather express with SX1262, SSD1306 OLED and NEO6M GPS
   *
   * @generated from enum value: TWC_MESH_V4 = 62;
   */
  TWC_MESH_V4 = 62,

  /**
   *
   * NRF52_PROMICRO_DIY
   * Promicro NRF52840 with SX1262/LLCC68, SSD1306 OLED and NEO6M GPS
   *
   * @generated from enum value: NRF52_PROMICRO_DIY = 63;
   */
  NRF52_PROMICRO_DIY = 63,

  /**
   *
   * RadioMaster 900 Bandit Nano, https://www.radiomasterrc.com/products/bandit-nano-expresslrs-rf-module
   * ESP32-D0WDQ6 With SX1276/SKY66122, SSD1306 OLED and No GPS
   *
   * @generated from enum value: RADIOMASTER_900_BANDIT_NANO = 64;
   */
  RADIOMASTER_900_BANDIT_NANO = 64,

  /**
   *
   * Heltec Capsule Sensor V3 with ESP32-S3 CPU, Portable LoRa device that can replace GNSS modules or sensors
   *
   * @generated from enum value: HELTEC_CAPSULE_SENSOR_V3 = 65;
   */
  HELTEC_CAPSULE_SENSOR_V3 = 65,

  /**
   *
   * Heltec Vision Master T190 with ESP32-S3 CPU, and a 1.90 inch TFT display
   *
   * @generated from enum value: HELTEC_VISION_MASTER_T190 = 66;
   */
  HELTEC_VISION_MASTER_T190 = 66,

  /**
   *
   * Heltec Vision Master E213 with ESP32-S3 CPU, and a 2.13 inch E-Ink display
   *
   * @generated from enum value: HELTEC_VISION_MASTER_E213 = 67;
   */
  HELTEC_VISION_MASTER_E213 = 67,

  /**
   *
   * Heltec Vision Master E290 with ESP32-S3 CPU, and a 2.9 inch E-Ink display
   *
   * @generated from enum value: HELTEC_VISION_MASTER_E290 = 68;
   */
  HELTEC_VISION_MASTER_E290 = 68,

  /**
   *
   * Heltec Mesh Node T114 board with nRF52840 CPU, and a 1.14 inch TFT display, Ultimate low-power design,
   * specifically adapted for the Meshtatic project
   *
   * @generated from enum value: HELTEC_MESH_NODE_T114 = 69;
   */
  HELTEC_MESH_NODE_T114 = 69,

  /**
   *
   * Sensecap Indicator from Seeed Studio. ESP32-S3 device with TFT and RP2040 coprocessor
   *
   * @generated from enum value: SENSECAP_INDICATOR = 70;
   */
  SENSECAP_INDICATOR = 70,

  /**
   *
   * Seeed studio T1000-E tracker card. NRF52840 w/ LR1110 radio, GPS, button, buzzer, and sensors.
   *
   * @generated from enum value: TRACKER_T1000_E = 71;
   */
  TRACKER_T1000_E = 71,

  /**
   *
   * RAK3172 STM32WLE5 Module (https://store.rakwireless.com/products/wisduo-lpwan-module-rak3172)
   *
   * @generated from enum value: RAK3172 = 72;
   */
  RAK3172 = 72,

  /**
   *
   * Seeed Studio Wio-E5 (either mini or Dev kit) using STM32WL chip.
   *
   * @generated from enum value: WIO_E5 = 73;
   */
  WIO_E5 = 73,

  /**
   *
   * RadioMaster 900 Bandit, https://www.radiomasterrc.com/products/bandit-expresslrs-rf-module
   * SSD1306 OLED and No GPS
   *
   * @generated from enum value: RADIOMASTER_900_BANDIT = 74;
   */
  RADIOMASTER_900_BANDIT = 74,

  /**
   *
   * Minewsemi ME25LS01 (ME25LE01_V1.0). NRF52840 w/ LR1110 radio, buttons and leds and pins.
   *
   * @generated from enum value: ME25LS01_4Y10TD = 75;
   */
  ME25LS01_4Y10TD = 75,

  /**
   *
   * RP2040_FEATHER_RFM95
   * Adafruit Feather RP2040 with RFM95 LoRa Radio RFM95 with SX1272, SSD1306 OLED
   * https://www.adafruit.com/product/5714
   * https://www.adafruit.com/product/326
   * https://www.adafruit.com/product/938
   *  ^^^ short A0 to switch to I2C address 0x3C
   *
   *
   * @generated from enum value: RP2040_FEATHER_RFM95 = 76;
   */
  RP2040_FEATHER_RFM95 = 76,

  /**
   * M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/ 
   *
   * @generated from enum value: M5STACK_COREBASIC = 77;
   */
  M5STACK_COREBASIC = 77,

  /**
   * @generated from enum value: M5STACK_CORE2 = 78;
   */
  M5STACK_CORE2 = 78,

  /**
   * Pico2 with Waveshare Hat, same as Pico 
   *
   * @generated from enum value: RPI_PICO2 = 79;
   */
  RPI_PICO2 = 79,

  /**
   * M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/ 
   *
   * @generated from enum value: M5STACK_CORES3 = 80;
   */
  M5STACK_CORES3 = 80,

  /**
   * Seeed XIAO S3 DK
   *
   * @generated from enum value: SEEED_XIAO_S3 = 81;
   */
  SEEED_XIAO_S3 = 81,

  /**
   *
   * Nordic nRF52840+Semtech SX1262 LoRa BLE Combo Module. nRF52840+SX1262 MS24SF1
   *
   * @generated from enum value: MS24SF1 = 82;
   */
  MS24SF1 = 82,

  /**
   *
   * Lilygo TLora-C6 with the new ESP32-C6 MCU
   *
   * @generated from enum value: TLORA_C6 = 83;
   */
  TLORA_C6 = 83,

  /**
   *
   * WisMesh Tap
   * RAK-4631 w/ TFT in injection modled case
   *
   * @generated from enum value: WISMESH_TAP = 84;
   */
  WISMESH_TAP = 84,

  /**
   *
   * Similar to PORTDUINO but used by Routastic devices, this is not any
   * particular device and does not run Meshtastic's code but supports
   * the same frame format.
   * Runs on linux, see https://github.com/Jorropo/routastic
   *
   * @generated from enum value: ROUTASTIC = 85;
   */
  ROUTASTIC = 85,

  /**
   *
   * Mesh-Tab, esp32 based
   * https://github.com/valzzu/Mesh-Tab
   *
   * @generated from enum value: MESH_TAB = 86;
   */
  MESH_TAB = 86,

  /**
   *
   * MeshLink board developed by LoraItalia. NRF52840, eByte E22900M22S (Will also come with other frequencies), 25w MPPT solar charger (5v,12v,18v selectable), support for gps, buzzer, oled or e-ink display, 10 gpios, hardware watchdog
   * https://www.loraitalia.it
   *
   * @generated from enum value: MESHLINK = 87;
   */
  MESHLINK = 87,

  /**
   *
   * Seeed XIAO nRF52840 + Wio SX1262 kit
   *
   * @generated from enum value: XIAO_NRF52_KIT = 88;
   */
  XIAO_NRF52_KIT = 88,

  /**
   *
   * Elecrow ThinkNode M1 & M2
   * https://www.elecrow.com/wiki/ThinkNode-M1_Transceiver_Device(Meshtastic)_Power_By_nRF52840.html
   * https://www.elecrow.com/wiki/ThinkNode-M2_Transceiver_Device(Meshtastic)_Power_By_NRF52840.html (this actually uses ESP32-S3)
   *
   * @generated from enum value: THINKNODE_M1 = 89;
   */
  THINKNODE_M1 = 89,

  /**
   * @generated from enum value: THINKNODE_M2 = 90;
   */
  THINKNODE_M2 = 90,

  /**
   *
   * Lilygo T-ETH-Elite
   *
   * @generated from enum value: T_ETH_ELITE = 91;
   */
  T_ETH_ELITE = 91,

  /**
   *
   * ------------------------------------------------------------------------------------------------------------------------------------------
   * Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits.
   * ------------------------------------------------------------------------------------------------------------------------------------------
   *
   * @generated from enum value: PRIVATE_HW = 255;
   */
  PRIVATE_HW = 255,
}

/**
 * Describes the enum meshtastic.HardwareModel.
 */
export const HardwareModelSchema: GenEnum<HardwareModel> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 0);

/**
 *
 * Shared constants between device and phone
 *
 * @generated from enum meshtastic.Constants
 */
export enum Constants {
  /**
   *
   * First enum must be zero, and we are just using this enum to
   * pass int constants between two very different environments
   *
   * @generated from enum value: ZERO = 0;
   */
  ZERO = 0,

  /**
   *
   * From mesh.options
   * note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
   * outside of this envelope
   *
   * @generated from enum value: DATA_PAYLOAD_LEN = 233;
   */
  DATA_PAYLOAD_LEN = 233,
}

/**
 * Describes the enum meshtastic.Constants.
 */
export const ConstantsSchema: GenEnum<Constants> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 1);

/**
 *
 * Error codes for critical errors
 * The device might report these fault codes on the screen.
 * If you encounter a fault code, please post on the meshtastic.discourse.group
 * and we'll try to help.
 *
 * @generated from enum meshtastic.CriticalErrorCode
 */
export enum CriticalErrorCode {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   *
   * A software bug was detected while trying to send lora
   *
   * @generated from enum value: TX_WATCHDOG = 1;
   */
  TX_WATCHDOG = 1,

  /**
   *
   * A software bug was detected on entry to sleep
   *
   * @generated from enum value: SLEEP_ENTER_WAIT = 2;
   */
  SLEEP_ENTER_WAIT = 2,

  /**
   *
   * No Lora radio hardware could be found
   *
   * @generated from enum value: NO_RADIO = 3;
   */
  NO_RADIO = 3,

  /**
   *
   * Not normally used
   *
   * @generated from enum value: UNSPECIFIED = 4;
   */
  UNSPECIFIED = 4,

  /**
   *
   * We failed while configuring a UBlox GPS
   *
   * @generated from enum value: UBLOX_UNIT_FAILED = 5;
   */
  UBLOX_UNIT_FAILED = 5,

  /**
   *
   * This board was expected to have a power management chip and it is missing or broken
   *
   * @generated from enum value: NO_AXP192 = 6;
   */
  NO_AXP192 = 6,

  /**
   *
   * The channel tried to set a radio setting which is not supported by this chipset,
   * radio comms settings are now undefined.
   *
   * @generated from enum value: INVALID_RADIO_SETTING = 7;
   */
  INVALID_RADIO_SETTING = 7,

  /**
   *
   * Radio transmit hardware failure. We sent data to the radio chip, but it didn't
   * reply with an interrupt.
   *
   * @generated from enum value: TRANSMIT_FAILED = 8;
   */
  TRANSMIT_FAILED = 8,

  /**
   *
   * We detected that the main CPU voltage dropped below the minimum acceptable value
   *
   * @generated from enum value: BROWNOUT = 9;
   */
  BROWNOUT = 9,

  /**
   * Selftest of SX1262 radio chip failed 
   *
   * @generated from enum value: SX1262_FAILURE = 10;
   */
  SX1262_FAILURE = 10,

  /**
   *
   * A (likely software but possibly hardware) failure was detected while trying to send packets.
   * If this occurs on your board, please post in the forum so that we can ask you to collect some information to allow fixing this bug
   *
   * @generated from enum value: RADIO_SPI_BUG = 11;
   */
  RADIO_SPI_BUG = 11,

  /**
   *
   * Corruption was detected on the flash filesystem but we were able to repair things.
   * If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
   *
   * @generated from enum value: FLASH_CORRUPTION_RECOVERABLE = 12;
   */
  FLASH_CORRUPTION_RECOVERABLE = 12,

  /**
   *
   * Corruption was detected on the flash filesystem but we were unable to repair things.
   * NOTE: Your node will probably need to be reconfigured the next time it reboots (it will lose the region code etc...)
   * If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
   *
   * @generated from enum value: FLASH_CORRUPTION_UNRECOVERABLE = 13;
   */
  FLASH_CORRUPTION_UNRECOVERABLE = 13,
}

/**
 * Describes the enum meshtastic.CriticalErrorCode.
 */
export const CriticalErrorCodeSchema: GenEnum<CriticalErrorCode> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 2);

/**
 *
 * Enum for modules excluded from a device's configuration.
 * Each value represents a ModuleConfigType that can be toggled as excluded
 * by setting its corresponding bit in the `excluded_modules` bitmask field.
 *
 * @generated from enum meshtastic.ExcludedModules
 */
export enum ExcludedModules {
  /**
   *
   * Default value of 0 indicates no modules are excluded.
   *
   * @generated from enum value: EXCLUDED_NONE = 0;
   */
  EXCLUDED_NONE = 0,

  /**
   *
   * MQTT module
   *
   * @generated from enum value: MQTT_CONFIG = 1;
   */
  MQTT_CONFIG = 1,

  /**
   *
   * Serial module
   *
   * @generated from enum value: SERIAL_CONFIG = 2;
   */
  SERIAL_CONFIG = 2,

  /**
   *
   * External Notification module
   *
   * @generated from enum value: EXTNOTIF_CONFIG = 4;
   */
  EXTNOTIF_CONFIG = 4,

  /**
   *
   * Store and Forward module
   *
   * @generated from enum value: STOREFORWARD_CONFIG = 8;
   */
  STOREFORWARD_CONFIG = 8,

  /**
   *
   * Range Test module
   *
   * @generated from enum value: RANGETEST_CONFIG = 16;
   */
  RANGETEST_CONFIG = 16,

  /**
   *
   * Telemetry module
   *
   * @generated from enum value: TELEMETRY_CONFIG = 32;
   */
  TELEMETRY_CONFIG = 32,

  /**
   *
   * Canned Message module
   *
   * @generated from enum value: CANNEDMSG_CONFIG = 64;
   */
  CANNEDMSG_CONFIG = 64,

  /**
   *
   * Audio module
   *
   * @generated from enum value: AUDIO_CONFIG = 128;
   */
  AUDIO_CONFIG = 128,

  /**
   *
   * Remote Hardware module
   *
   * @generated from enum value: REMOTEHARDWARE_CONFIG = 256;
   */
  REMOTEHARDWARE_CONFIG = 256,

  /**
   *
   * Neighbor Info module
   *
   * @generated from enum value: NEIGHBORINFO_CONFIG = 512;
   */
  NEIGHBORINFO_CONFIG = 512,

  /**
   *
   * Ambient Lighting module
   *
   * @generated from enum value: AMBIENTLIGHTING_CONFIG = 1024;
   */
  AMBIENTLIGHTING_CONFIG = 1024,

  /**
   *
   * Detection Sensor module
   *
   * @generated from enum value: DETECTIONSENSOR_CONFIG = 2048;
   */
  DETECTIONSENSOR_CONFIG = 2048,

  /**
   *
   * Paxcounter module
   *
   * @generated from enum value: PAXCOUNTER_CONFIG = 4096;
   */
  PAXCOUNTER_CONFIG = 4096,
}

/**
 * Describes the enum meshtastic.ExcludedModules.
 */
export const ExcludedModulesSchema: GenEnum<ExcludedModules> = /*@__PURE__*/
  enumDesc(file_meshtastic_mesh, 3);

