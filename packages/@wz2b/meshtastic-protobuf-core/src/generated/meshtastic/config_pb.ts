// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=js"
// @generated from file meshtastic/config.proto (package meshtastic, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { DeviceUIConfig } from "./device_ui_pb.js";
import { file_meshtastic_device_ui } from "./device_ui_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file meshtastic/config.proto.
 */
export const file_meshtastic_config: GenFile = /*@__PURE__*/
  fileDesc("ChdtZXNodGFzdGljL2NvbmZpZy5wcm90bxIKbWVzaHRhc3RpYyLUJgoGQ29uZmlnEjEKBmRldmljZRgBIAEoCzIfLm1lc2h0YXN0aWMuQ29uZmlnLkRldmljZUNvbmZpZ0gAEjUKCHBvc2l0aW9uGAIgASgLMiEubWVzaHRhc3RpYy5Db25maWcuUG9zaXRpb25Db25maWdIABIvCgVwb3dlchgDIAEoCzIeLm1lc2h0YXN0aWMuQ29uZmlnLlBvd2VyQ29uZmlnSAASMwoHbmV0d29yaxgEIAEoCzIgLm1lc2h0YXN0aWMuQ29uZmlnLk5ldHdvcmtDb25maWdIABIzCgdkaXNwbGF5GAUgASgLMiAubWVzaHRhc3RpYy5Db25maWcuRGlzcGxheUNvbmZpZ0gAEi0KBGxvcmEYBiABKAsyHS5tZXNodGFzdGljLkNvbmZpZy5Mb1JhQ29uZmlnSAASNwoJYmx1ZXRvb3RoGAcgASgLMiIubWVzaHRhc3RpYy5Db25maWcuQmx1ZXRvb3RoQ29uZmlnSAASNQoIc2VjdXJpdHkYCCABKAsyIS5tZXNodGFzdGljLkNvbmZpZy5TZWN1cml0eUNvbmZpZ0gAEjkKCnNlc3Npb25rZXkYCSABKAsyIy5tZXNodGFzdGljLkNvbmZpZy5TZXNzaW9ua2V5Q29uZmlnSAASLwoJZGV2aWNlX3VpGAogASgLMhoubWVzaHRhc3RpYy5EZXZpY2VVSUNvbmZpZ0gAGrUFCgxEZXZpY2VDb25maWcSMgoEcm9sZRgBIAEoDjIkLm1lc2h0YXN0aWMuQ29uZmlnLkRldmljZUNvbmZpZy5Sb2xlEhoKDnNlcmlhbF9lbmFibGVkGAIgASgIQgIYARITCgtidXR0b25fZ3BpbxgEIAEoDRITCgtidXp6ZXJfZ3BpbxgFIAEoDRJJChByZWJyb2FkY2FzdF9tb2RlGAYgASgOMi8ubWVzaHRhc3RpYy5Db25maWcuRGV2aWNlQ29uZmlnLlJlYnJvYWRjYXN0TW9kZRIgChhub2RlX2luZm9fYnJvYWRjYXN0X3NlY3MYByABKA0SIgoaZG91YmxlX3RhcF9hc19idXR0b25fcHJlc3MYCCABKAgSFgoKaXNfbWFuYWdlZBgJIAEoCEICGAESHAoUZGlzYWJsZV90cmlwbGVfY2xpY2sYCiABKAgSDQoFdHpkZWYYCyABKAkSHgoWbGVkX2hlYXJ0YmVhdF9kaXNhYmxlZBgMIAEoCCK/AQoEUm9sZRIKCgZDTElFTlQQABIPCgtDTElFTlRfTVVURRABEgoKBlJPVVRFUhACEhUKDVJPVVRFUl9DTElFTlQQAxoCCAESDAoIUkVQRUFURVIQBBILCgdUUkFDS0VSEAUSCgoGU0VOU09SEAYSBwoDVEFLEAcSEQoNQ0xJRU5UX0hJRERFThAIEhIKDkxPU1RfQU5EX0ZPVU5EEAkSDwoLVEFLX1RSQUNLRVIQChIPCgtST1VURVJfTEFURRALInMKD1JlYnJvYWRjYXN0TW9kZRIHCgNBTEwQABIVChFBTExfU0tJUF9ERUNPRElORxABEg4KCkxPQ0FMX09OTFkQAhIOCgpLTk9XTl9PTkxZEAMSCAoETk9ORRAEEhYKEkNPUkVfUE9SVE5VTVNfT05MWRAFGpEFCg5Qb3NpdGlvbkNvbmZpZxIfChdwb3NpdGlvbl9icm9hZGNhc3Rfc2VjcxgBIAEoDRIoCiBwb3NpdGlvbl9icm9hZGNhc3Rfc21hcnRfZW5hYmxlZBgCIAEoCBIWCg5maXhlZF9wb3NpdGlvbhgDIAEoCBIXCgtncHNfZW5hYmxlZBgEIAEoCEICGAESGwoTZ3BzX3VwZGF0ZV9pbnRlcnZhbBgFIAEoDRIcChBncHNfYXR0ZW1wdF90aW1lGAYgASgNQgIYARIWCg5wb3NpdGlvbl9mbGFncxgHIAEoDRIPCgdyeF9ncGlvGAggASgNEg8KB3R4X2dwaW8YCSABKA0SKAogYnJvYWRjYXN0X3NtYXJ0X21pbmltdW1fZGlzdGFuY2UYCiABKA0SLQolYnJvYWRjYXN0X3NtYXJ0X21pbmltdW1faW50ZXJ2YWxfc2VjcxgLIAEoDRITCgtncHNfZW5fZ3BpbxgMIAEoDRI7CghncHNfbW9kZRgNIAEoDjIpLm1lc2h0YXN0aWMuQ29uZmlnLlBvc2l0aW9uQ29uZmlnLkdwc01vZGUiqwEKDVBvc2l0aW9uRmxhZ3MSCQoFVU5TRVQQABIMCghBTFRJVFVERRABEhAKDEFMVElUVURFX01TTBACEhYKEkdFT0lEQUxfU0VQQVJBVElPThAEEgcKA0RPUBAIEgkKBUhWRE9QEBASDQoJU0FUSU5WSUVXECASCgoGU0VRX05PEEASDgoJVElNRVNUQU1QEIABEgwKB0hFQURJTkcQgAISCgoFU1BFRUQQgAQiNQoHR3BzTW9kZRIMCghESVNBQkxFRBAAEgsKB0VOQUJMRUQQARIPCgtOT1RfUFJFU0VOVBACGoQCCgtQb3dlckNvbmZpZxIXCg9pc19wb3dlcl9zYXZpbmcYASABKAgSJgoeb25fYmF0dGVyeV9zaHV0ZG93bl9hZnRlcl9zZWNzGAIgASgNEh8KF2FkY19tdWx0aXBsaWVyX292ZXJyaWRlGAMgASgCEhsKE3dhaXRfYmx1ZXRvb3RoX3NlY3MYBCABKA0SEAoIc2RzX3NlY3MYBiABKA0SDwoHbHNfc2VjcxgHIAEoDRIVCg1taW5fd2FrZV9zZWNzGAggASgNEiIKGmRldmljZV9iYXR0ZXJ5X2luYV9hZGRyZXNzGAkgASgNEhgKEHBvd2VybW9uX2VuYWJsZXMYICABKAQazwMKDU5ldHdvcmtDb25maWcSFAoMd2lmaV9lbmFibGVkGAEgASgIEhEKCXdpZmlfc3NpZBgDIAEoCRIQCgh3aWZpX3BzaxgEIAEoCRISCgpudHBfc2VydmVyGAUgASgJEhMKC2V0aF9lbmFibGVkGAYgASgIEkIKDGFkZHJlc3NfbW9kZRgHIAEoDjIsLm1lc2h0YXN0aWMuQ29uZmlnLk5ldHdvcmtDb25maWcuQWRkcmVzc01vZGUSQAoLaXB2NF9jb25maWcYCCABKAsyKy5tZXNodGFzdGljLkNvbmZpZy5OZXR3b3JrQ29uZmlnLklwVjRDb25maWcSFgoOcnN5c2xvZ19zZXJ2ZXIYCSABKAkSGQoRZW5hYmxlZF9wcm90b2NvbHMYCiABKA0aRgoKSXBWNENvbmZpZxIKCgJpcBgBIAEoBxIPCgdnYXRld2F5GAIgASgHEg4KBnN1Ym5ldBgDIAEoBxILCgNkbnMYBCABKAciIwoLQWRkcmVzc01vZGUSCAoEREhDUBAAEgoKBlNUQVRJQxABIjQKDVByb3RvY29sRmxhZ3MSEAoMTk9fQlJPQURDQVNUEAASEQoNVURQX0JST0FEQ0FTVBABGuQHCg1EaXNwbGF5Q29uZmlnEhYKDnNjcmVlbl9vbl9zZWNzGAEgASgNEkgKCmdwc19mb3JtYXQYAiABKA4yNC5tZXNodGFzdGljLkNvbmZpZy5EaXNwbGF5Q29uZmlnLkdwc0Nvb3JkaW5hdGVGb3JtYXQSIQoZYXV0b19zY3JlZW5fY2Fyb3VzZWxfc2VjcxgDIAEoDRIZChFjb21wYXNzX25vcnRoX3RvcBgEIAEoCBITCgtmbGlwX3NjcmVlbhgFIAEoCBI8CgV1bml0cxgGIAEoDjItLm1lc2h0YXN0aWMuQ29uZmlnLkRpc3BsYXlDb25maWcuRGlzcGxheVVuaXRzEjcKBG9sZWQYByABKA4yKS5tZXNodGFzdGljLkNvbmZpZy5EaXNwbGF5Q29uZmlnLk9sZWRUeXBlEkEKC2Rpc3BsYXltb2RlGAggASgOMiwubWVzaHRhc3RpYy5Db25maWcuRGlzcGxheUNvbmZpZy5EaXNwbGF5TW9kZRIUCgxoZWFkaW5nX2JvbGQYCSABKAgSHQoVd2FrZV9vbl90YXBfb3JfbW90aW9uGAogASgIElAKE2NvbXBhc3Nfb3JpZW50YXRpb24YCyABKA4yMy5tZXNodGFzdGljLkNvbmZpZy5EaXNwbGF5Q29uZmlnLkNvbXBhc3NPcmllbnRhdGlvbhIVCg11c2VfMTJoX2Nsb2NrGAwgASgIIk0KE0dwc0Nvb3JkaW5hdGVGb3JtYXQSBwoDREVDEAASBwoDRE1TEAESBwoDVVRNEAISCAoETUdSUxADEgcKA09MQxAEEggKBE9TR1IQBSIoCgxEaXNwbGF5VW5pdHMSCgoGTUVUUklDEAASDAoISU1QRVJJQUwQASJNCghPbGVkVHlwZRINCglPTEVEX0FVVE8QABIQCgxPTEVEX1NTRDEzMDYQARIPCgtPTEVEX1NIMTEwNhACEg8KC09MRURfU0gxMTA3EAMiQQoLRGlzcGxheU1vZGUSCwoHREVGQVVMVBAAEgwKCFRXT0NPTE9SEAESDAoISU5WRVJURUQQAhIJCgVDT0xPUhADIroBChJDb21wYXNzT3JpZW50YXRpb24SDQoJREVHUkVFU18wEAASDgoKREVHUkVFU185MBABEg8KC0RFR1JFRVNfMTgwEAISDwoLREVHUkVFU18yNzAQAxIWChJERUdSRUVTXzBfSU5WRVJURUQQBBIXChNERUdSRUVTXzkwX0lOVkVSVEVEEAUSGAoUREVHUkVFU18xODBfSU5WRVJURUQQBhIYChRERUdSRUVTXzI3MF9JTlZFUlRFRBAHGp0HCgpMb1JhQ29uZmlnEhIKCnVzZV9wcmVzZXQYASABKAgSPwoMbW9kZW1fcHJlc2V0GAIgASgOMikubWVzaHRhc3RpYy5Db25maWcuTG9SYUNvbmZpZy5Nb2RlbVByZXNldBIRCgliYW5kd2lkdGgYAyABKA0SFQoNc3ByZWFkX2ZhY3RvchgEIAEoDRITCgtjb2RpbmdfcmF0ZRgFIAEoDRIYChBmcmVxdWVuY3lfb2Zmc2V0GAYgASgCEjgKBnJlZ2lvbhgHIAEoDjIoLm1lc2h0YXN0aWMuQ29uZmlnLkxvUmFDb25maWcuUmVnaW9uQ29kZRIRCglob3BfbGltaXQYCCABKA0SEgoKdHhfZW5hYmxlZBgJIAEoCBIQCgh0eF9wb3dlchgKIAEoBRITCgtjaGFubmVsX251bRgLIAEoDRIbChNvdmVycmlkZV9kdXR5X2N5Y2xlGAwgASgIEh4KFnN4MTI2eF9yeF9ib29zdGVkX2dhaW4YDSABKAgSGgoSb3ZlcnJpZGVfZnJlcXVlbmN5GA4gASgCEhcKD3BhX2Zhbl9kaXNhYmxlZBgPIAEoCBIXCg9pZ25vcmVfaW5jb21pbmcYZyADKA0SEwoLaWdub3JlX21xdHQYaCABKAgSGQoRY29uZmlnX29rX3RvX21xdHQYaSABKAgi8QEKClJlZ2lvbkNvZGUSCQoFVU5TRVQQABIGCgJVUxABEgoKBkVVXzQzMxACEgoKBkVVXzg2OBADEgYKAkNOEAQSBgoCSlAQBRIHCgNBTloQBhIGCgJLUhAHEgYKAlRXEAgSBgoCUlUQCRIGCgJJThAKEgoKBk5aXzg2NRALEgYKAlRIEAwSCwoHTE9SQV8yNBANEgoKBlVBXzQzMxAOEgoKBlVBXzg2OBAPEgoKBk1ZXzQzMxAQEgoKBk1ZXzkxORAREgoKBlNHXzkyMxASEgoKBlBIXzQzMxATEgoKBlBIXzg2OBAUEgoKBlBIXzkxNRAVIqkBCgtNb2RlbVByZXNldBINCglMT05HX0ZBU1QQABINCglMT05HX1NMT1cQARIWCg5WRVJZX0xPTkdfU0xPVxACGgIIARIPCgtNRURJVU1fU0xPVxADEg8KC01FRElVTV9GQVNUEAQSDgoKU0hPUlRfU0xPVxAFEg4KClNIT1JUX0ZBU1QQBhIRCg1MT05HX01PREVSQVRFEAcSDwoLU0hPUlRfVFVSQk8QCBqtAQoPQmx1ZXRvb3RoQ29uZmlnEg8KB2VuYWJsZWQYASABKAgSPAoEbW9kZRgCIAEoDjIuLm1lc2h0YXN0aWMuQ29uZmlnLkJsdWV0b290aENvbmZpZy5QYWlyaW5nTW9kZRIRCglmaXhlZF9waW4YAyABKA0iOAoLUGFpcmluZ01vZGUSDgoKUkFORE9NX1BJThAAEg0KCUZJWEVEX1BJThABEgoKBk5PX1BJThACGrYBCg5TZWN1cml0eUNvbmZpZxISCgpwdWJsaWNfa2V5GAEgASgMEhMKC3ByaXZhdGVfa2V5GAIgASgMEhEKCWFkbWluX2tleRgDIAMoDBISCgppc19tYW5hZ2VkGAQgASgIEhYKDnNlcmlhbF9lbmFibGVkGAUgASgIEh0KFWRlYnVnX2xvZ19hcGlfZW5hYmxlZBgGIAEoCBIdChVhZG1pbl9jaGFubmVsX2VuYWJsZWQYCCABKAgaEgoQU2Vzc2lvbmtleUNvbmZpZ0IRCg9wYXlsb2FkX3ZhcmlhbnRCYQoTY29tLmdlZWtzdmlsbGUubWVzaEIMQ29uZmlnUHJvdG9zWiJnaXRodWIuY29tL21lc2h0YXN0aWMvZ28vZ2VuZXJhdGVkqgIUTWVzaHRhc3RpYy5Qcm90b2J1ZnO6AgBiBnByb3RvMw", [file_meshtastic_device_ui]);

/**
 * @generated from message meshtastic.Config
 */
export type Config = Message<"meshtastic.Config"> & {
  /**
   *
   * Payload Variant
   *
   * @generated from oneof meshtastic.Config.payload_variant
   */
  payloadVariant: {
    /**
     * @generated from field: meshtastic.Config.DeviceConfig device = 1;
     */
    value: Config_DeviceConfig;
    case: "device";
  } | {
    /**
     * @generated from field: meshtastic.Config.PositionConfig position = 2;
     */
    value: Config_PositionConfig;
    case: "position";
  } | {
    /**
     * @generated from field: meshtastic.Config.PowerConfig power = 3;
     */
    value: Config_PowerConfig;
    case: "power";
  } | {
    /**
     * @generated from field: meshtastic.Config.NetworkConfig network = 4;
     */
    value: Config_NetworkConfig;
    case: "network";
  } | {
    /**
     * @generated from field: meshtastic.Config.DisplayConfig display = 5;
     */
    value: Config_DisplayConfig;
    case: "display";
  } | {
    /**
     * @generated from field: meshtastic.Config.LoRaConfig lora = 6;
     */
    value: Config_LoRaConfig;
    case: "lora";
  } | {
    /**
     * @generated from field: meshtastic.Config.BluetoothConfig bluetooth = 7;
     */
    value: Config_BluetoothConfig;
    case: "bluetooth";
  } | {
    /**
     * @generated from field: meshtastic.Config.SecurityConfig security = 8;
     */
    value: Config_SecurityConfig;
    case: "security";
  } | {
    /**
     * @generated from field: meshtastic.Config.SessionkeyConfig sessionkey = 9;
     */
    value: Config_SessionkeyConfig;
    case: "sessionkey";
  } | {
    /**
     * @generated from field: meshtastic.DeviceUIConfig device_ui = 10;
     */
    value: DeviceUIConfig;
    case: "deviceUi";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message meshtastic.Config.
 * Use `create(ConfigSchema)` to create a new message.
 */
export const ConfigSchema: GenMessage<Config> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0);

/**
 *
 * Configuration
 *
 * @generated from message meshtastic.Config.DeviceConfig
 */
export type Config_DeviceConfig = Message<"meshtastic.Config.DeviceConfig"> & {
  /**
   *
   * Sets the role of node
   *
   * @generated from field: meshtastic.Config.DeviceConfig.Role role = 1;
   */
  role: Config_DeviceConfig_Role;

  /**
   *
   * Disabling this will disable the SerialConsole by not initilizing the StreamAPI
   * Moved to SecurityConfig
   *
   * @generated from field: bool serial_enabled = 2 [deprecated = true];
   * @deprecated
   */
  serialEnabled: boolean;

  /**
   *
   * For boards without a hard wired button, this is the pin number that will be used
   * Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
   *
   * @generated from field: uint32 button_gpio = 4;
   */
  buttonGpio: number;

  /**
   *
   * For boards without a PWM buzzer, this is the pin number that will be used
   * Defaults to PIN_BUZZER if defined.
   *
   * @generated from field: uint32 buzzer_gpio = 5;
   */
  buzzerGpio: number;

  /**
   *
   * Sets the role of node
   *
   * @generated from field: meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;
   */
  rebroadcastMode: Config_DeviceConfig_RebroadcastMode;

  /**
   *
   * Send our nodeinfo this often
   * Defaults to 900 Seconds (15 minutes)
   *
   * @generated from field: uint32 node_info_broadcast_secs = 7;
   */
  nodeInfoBroadcastSecs: number;

  /**
   *
   * Treat double tap interrupt on supported accelerometers as a button press if set to true
   *
   * @generated from field: bool double_tap_as_button_press = 8;
   */
  doubleTapAsButtonPress: boolean;

  /**
   *
   * If true, device is considered to be "managed" by a mesh administrator
   * Clients should then limit available configuration and administrative options inside the user interface
   * Moved to SecurityConfig
   *
   * @generated from field: bool is_managed = 9 [deprecated = true];
   * @deprecated
   */
  isManaged: boolean;

  /**
   *
   * Disables the triple-press of user button to enable or disable GPS
   *
   * @generated from field: bool disable_triple_click = 10;
   */
  disableTripleClick: boolean;

  /**
   *
   * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
   *
   * @generated from field: string tzdef = 11;
   */
  tzdef: string;

  /**
   *
   * If true, disable the default blinking LED (LED_PIN) behavior on the device
   *
   * @generated from field: bool led_heartbeat_disabled = 12;
   */
  ledHeartbeatDisabled: boolean;
};

/**
 * Describes the message meshtastic.Config.DeviceConfig.
 * Use `create(Config_DeviceConfigSchema)` to create a new message.
 */
export const Config_DeviceConfigSchema: GenMessage<Config_DeviceConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 0);

/**
 *
 * Defines the device's role on the Mesh network
 *
 * @generated from enum meshtastic.Config.DeviceConfig.Role
 */
export enum Config_DeviceConfig_Role {
  /**
   *
   * Description: App connected or stand alone messaging device.
   * Technical Details: Default Role
   *
   * @generated from enum value: CLIENT = 0;
   */
  CLIENT = 0,

  /**
   *
   *  Description: Device that does not forward packets from other devices.
   *
   * @generated from enum value: CLIENT_MUTE = 1;
   */
  CLIENT_MUTE = 1,

  /**
   *
   * Description: Infrastructure node for extending network coverage by relaying messages. Visible in Nodes list.
   * Technical Details: Mesh packets will prefer to be routed over this node. This node will not be used by client apps.
   *   The wifi radio and the oled screen will be put to sleep.
   *   This mode may still potentially have higher power usage due to it's preference in message rebroadcasting on the mesh.
   *
   * @generated from enum value: ROUTER = 2;
   */
  ROUTER = 2,

  /**
   * @generated from enum value: ROUTER_CLIENT = 3 [deprecated = true];
   * @deprecated
   */
  ROUTER_CLIENT = 3,

  /**
   *
   * Description: Infrastructure node for extending network coverage by relaying messages with minimal overhead. Not visible in Nodes list.
   * Technical Details: Mesh packets will simply be rebroadcasted over this node. Nodes configured with this role will not originate NodeInfo, Position, Telemetry
   *   or any other packet type. They will simply rebroadcast any mesh packets on the same frequency, channel num, spread factor, and coding rate.
   *
   * @generated from enum value: REPEATER = 4;
   */
  REPEATER = 4,

  /**
   *
   * Description: Broadcasts GPS position packets as priority.
   * Technical Details: Position Mesh packets will be prioritized higher and sent more frequently by default.
   *   When used in conjunction with power.is_power_saving = true, nodes will wake up,
   *   send position, and then sleep for position.position_broadcast_secs seconds.
   *
   * @generated from enum value: TRACKER = 5;
   */
  TRACKER = 5,

  /**
   *
   * Description: Broadcasts telemetry packets as priority.
   * Technical Details: Telemetry Mesh packets will be prioritized higher and sent more frequently by default.
   *   When used in conjunction with power.is_power_saving = true, nodes will wake up,
   *   send environment telemetry, and then sleep for telemetry.environment_update_interval seconds.
   *
   * @generated from enum value: SENSOR = 6;
   */
  SENSOR = 6,

  /**
   *
   * Description: Optimized for ATAK system communication and reduces routine broadcasts.
   * Technical Details: Used for nodes dedicated for connection to an ATAK EUD.
   *    Turns off many of the routine broadcasts to favor CoT packet stream
   *    from the Meshtastic ATAK plugin -> IMeshService -> Node
   *
   * @generated from enum value: TAK = 7;
   */
  TAK = 7,

  /**
   *
   * Description: Device that only broadcasts as needed for stealth or power savings.
   * Technical Details: Used for nodes that "only speak when spoken to"
   *    Turns all of the routine broadcasts but allows for ad-hoc communication
   *    Still rebroadcasts, but with local only rebroadcast mode (known meshes only)
   *    Can be used for clandestine operation or to dramatically reduce airtime / power consumption
   *
   * @generated from enum value: CLIENT_HIDDEN = 8;
   */
  CLIENT_HIDDEN = 8,

  /**
   *
   * Description: Broadcasts location as message to default channel regularly for to assist with device recovery.
   * Technical Details: Used to automatically send a text message to the mesh
   *    with the current position of the device on a frequent interval:
   *    "I'm lost! Position: lat / long"
   *
   * @generated from enum value: LOST_AND_FOUND = 9;
   */
  LOST_AND_FOUND = 9,

  /**
   *
   * Description: Enables automatic TAK PLI broadcasts and reduces routine broadcasts.
   * Technical Details: Turns off many of the routine broadcasts to favor ATAK CoT packet stream
   *    and automatic TAK PLI (position location information) broadcasts.
   *    Uses position module configuration to determine TAK PLI broadcast interval.
   *
   * @generated from enum value: TAK_TRACKER = 10;
   */
  TAK_TRACKER = 10,

  /**
   *
   * Description: Will always rebroadcast packets, but will do so after all other modes.
   * Technical Details: Used for router nodes that are intended to provide additional coverage
   *    in areas not already covered by other routers, or to bridge around problematic terrain,
   *    but should not be given priority over other routers in order to avoid unnecessaraily
   *    consuming hops.
   *
   * @generated from enum value: ROUTER_LATE = 11;
   */
  ROUTER_LATE = 11,
}

/**
 * Describes the enum meshtastic.Config.DeviceConfig.Role.
 */
export const Config_DeviceConfig_RoleSchema: GenEnum<Config_DeviceConfig_Role> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 0, 0);

/**
 *
 * Defines the device's behavior for how messages are rebroadcast
 *
 * @generated from enum meshtastic.Config.DeviceConfig.RebroadcastMode
 */
export enum Config_DeviceConfig_RebroadcastMode {
  /**
   *
   * Default behavior.
   * Rebroadcast any observed message, if it was on our private channel or from another mesh with the same lora params.
   *
   * @generated from enum value: ALL = 0;
   */
  ALL = 0,

  /**
   *
   * Same as behavior as ALL but skips packet decoding and simply rebroadcasts them.
   * Only available in Repeater role. Setting this on any other roles will result in ALL behavior.
   *
   * @generated from enum value: ALL_SKIP_DECODING = 1;
   */
  ALL_SKIP_DECODING = 1,

  /**
   *
   * Ignores observed messages from foreign meshes that are open or those which it cannot decrypt.
   * Only rebroadcasts message on the nodes local primary / secondary channels.
   *
   * @generated from enum value: LOCAL_ONLY = 2;
   */
  LOCAL_ONLY = 2,

  /**
   *
   * Ignores observed messages from foreign meshes like LOCAL_ONLY,
   * but takes it step further by also ignoring messages from nodenums not in the node's known list (NodeDB)
   *
   * @generated from enum value: KNOWN_ONLY = 3;
   */
  KNOWN_ONLY = 3,

  /**
   *
   * Only permitted for SENSOR, TRACKER and TAK_TRACKER roles, this will inhibit all rebroadcasts, not unlike CLIENT_MUTE role.
   *
   * @generated from enum value: NONE = 4;
   */
  NONE = 4,

  /**
   *
   * Ignores packets from non-standard portnums such as: TAK, RangeTest, PaxCounter, etc.
   * Only rebroadcasts packets with standard portnums: NodeInfo, Text, Position, Telemetry, and Routing.
   *
   * @generated from enum value: CORE_PORTNUMS_ONLY = 5;
   */
  CORE_PORTNUMS_ONLY = 5,
}

/**
 * Describes the enum meshtastic.Config.DeviceConfig.RebroadcastMode.
 */
export const Config_DeviceConfig_RebroadcastModeSchema: GenEnum<Config_DeviceConfig_RebroadcastMode> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 0, 1);

/**
 *
 * Position Config
 *
 * @generated from message meshtastic.Config.PositionConfig
 */
export type Config_PositionConfig = Message<"meshtastic.Config.PositionConfig"> & {
  /**
   *
   * We should send our position this often (but only if it has changed significantly)
   * Defaults to 15 minutes
   *
   * @generated from field: uint32 position_broadcast_secs = 1;
   */
  positionBroadcastSecs: number;

  /**
   *
   * Adaptive position braoadcast, which is now the default.
   *
   * @generated from field: bool position_broadcast_smart_enabled = 2;
   */
  positionBroadcastSmartEnabled: boolean;

  /**
   *
   * If set, this node is at a fixed position.
   * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
   * The lat/lon/alt can be set by an internal GPS or with the help of the app.
   *
   * @generated from field: bool fixed_position = 3;
   */
  fixedPosition: boolean;

  /**
   *
   * Is GPS enabled for this node?
   *
   * @generated from field: bool gps_enabled = 4 [deprecated = true];
   * @deprecated
   */
  gpsEnabled: boolean;

  /**
   *
   * How often should we try to get GPS position (in seconds)
   * or zero for the default of once every 30 seconds
   * or a very large value (maxint) to update only once at boot.
   *
   * @generated from field: uint32 gps_update_interval = 5;
   */
  gpsUpdateInterval: number;

  /**
   *
   * Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
   *
   * @generated from field: uint32 gps_attempt_time = 6 [deprecated = true];
   * @deprecated
   */
  gpsAttemptTime: number;

  /**
   *
   * Bit field of boolean configuration options for POSITION messages
   * (bitwise OR of PositionFlags)
   *
   * @generated from field: uint32 position_flags = 7;
   */
  positionFlags: number;

  /**
   *
   * (Re)define GPS_RX_PIN for your board.
   *
   * @generated from field: uint32 rx_gpio = 8;
   */
  rxGpio: number;

  /**
   *
   * (Re)define GPS_TX_PIN for your board.
   *
   * @generated from field: uint32 tx_gpio = 9;
   */
  txGpio: number;

  /**
   *
   * The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
   *
   * @generated from field: uint32 broadcast_smart_minimum_distance = 10;
   */
  broadcastSmartMinimumDistance: number;

  /**
   *
   * The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
   *
   * @generated from field: uint32 broadcast_smart_minimum_interval_secs = 11;
   */
  broadcastSmartMinimumIntervalSecs: number;

  /**
   *
   * (Re)define PIN_GPS_EN for your board.
   *
   * @generated from field: uint32 gps_en_gpio = 12;
   */
  gpsEnGpio: number;

  /**
   *
   * Set where GPS is enabled, disabled, or not present
   *
   * @generated from field: meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;
   */
  gpsMode: Config_PositionConfig_GpsMode;
};

/**
 * Describes the message meshtastic.Config.PositionConfig.
 * Use `create(Config_PositionConfigSchema)` to create a new message.
 */
export const Config_PositionConfigSchema: GenMessage<Config_PositionConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 1);

/**
 *
 * Bit field of boolean configuration options, indicating which optional
 * fields to include when assembling POSITION messages.
 * Longitude, latitude, altitude, speed, heading, and DOP
 * are always included (also time if GPS-synced)
 * NOTE: the more fields are included, the larger the message will be -
 *   leading to longer airtime and a higher risk of packet loss
 *
 * @generated from enum meshtastic.Config.PositionConfig.PositionFlags
 */
export enum Config_PositionConfig_PositionFlags {
  /**
   *
   * Required for compilation
   *
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   *
   * Include an altitude value (if available)
   *
   * @generated from enum value: ALTITUDE = 1;
   */
  ALTITUDE = 1,

  /**
   *
   * Altitude value is MSL
   *
   * @generated from enum value: ALTITUDE_MSL = 2;
   */
  ALTITUDE_MSL = 2,

  /**
   *
   * Include geoidal separation
   *
   * @generated from enum value: GEOIDAL_SEPARATION = 4;
   */
  GEOIDAL_SEPARATION = 4,

  /**
   *
   * Include the DOP value ; PDOP used by default, see below
   *
   * @generated from enum value: DOP = 8;
   */
  DOP = 8,

  /**
   *
   * If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
   *
   * @generated from enum value: HVDOP = 16;
   */
  HVDOP = 16,

  /**
   *
   * Include number of "satellites in view"
   *
   * @generated from enum value: SATINVIEW = 32;
   */
  SATINVIEW = 32,

  /**
   *
   * Include a sequence number incremented per packet
   *
   * @generated from enum value: SEQ_NO = 64;
   */
  SEQ_NO = 64,

  /**
   *
   * Include positional timestamp (from GPS solution)
   *
   * @generated from enum value: TIMESTAMP = 128;
   */
  TIMESTAMP = 128,

  /**
   *
   * Include positional heading
   * Intended for use with vehicle not walking speeds
   * walking speeds are likely to be error prone like the compass
   *
   * @generated from enum value: HEADING = 256;
   */
  HEADING = 256,

  /**
   *
   * Include positional speed
   * Intended for use with vehicle not walking speeds
   * walking speeds are likely to be error prone like the compass
   *
   * @generated from enum value: SPEED = 512;
   */
  SPEED = 512,
}

/**
 * Describes the enum meshtastic.Config.PositionConfig.PositionFlags.
 */
export const Config_PositionConfig_PositionFlagsSchema: GenEnum<Config_PositionConfig_PositionFlags> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 1, 0);

/**
 * @generated from enum meshtastic.Config.PositionConfig.GpsMode
 */
export enum Config_PositionConfig_GpsMode {
  /**
   *
   * GPS is present but disabled
   *
   * @generated from enum value: DISABLED = 0;
   */
  DISABLED = 0,

  /**
   *
   * GPS is present and enabled
   *
   * @generated from enum value: ENABLED = 1;
   */
  ENABLED = 1,

  /**
   *
   * GPS is not present on the device
   *
   * @generated from enum value: NOT_PRESENT = 2;
   */
  NOT_PRESENT = 2,
}

/**
 * Describes the enum meshtastic.Config.PositionConfig.GpsMode.
 */
export const Config_PositionConfig_GpsModeSchema: GenEnum<Config_PositionConfig_GpsMode> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 1, 1);

/**
 *
 * Power Config\
 * See [Power Config](/docs/settings/config/power) for additional power config details.
 *
 * @generated from message meshtastic.Config.PowerConfig
 */
export type Config_PowerConfig = Message<"meshtastic.Config.PowerConfig"> & {
  /**
   *
   * Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
   * Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
   * Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
   *
   * @generated from field: bool is_power_saving = 1;
   */
  isPowerSaving: boolean;

  /**
   *
   *  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
   *
   * @generated from field: uint32 on_battery_shutdown_after_secs = 2;
   */
  onBatteryShutdownAfterSecs: number;

  /**
   *
   * Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
   * Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
   * https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
   * Should be set to floating point value between 2 and 6
   *
   * @generated from field: float adc_multiplier_override = 3;
   */
  adcMultiplierOverride: number;

  /**
   *
   *  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
   *  Technical Details: ESP32 Only 0 for default of 1 minute
   *
   * @generated from field: uint32 wait_bluetooth_secs = 4;
   */
  waitBluetoothSecs: number;

  /**
   *
   * Super Deep Sleep Seconds
   * While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
   * for this value (default 1 year) or a button press
   * 0 for default of one year
   *
   * @generated from field: uint32 sds_secs = 6;
   */
  sdsSecs: number;

  /**
   *
   * Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
   * Technical Details: ESP32 Only 0 for default of 300
   *
   * @generated from field: uint32 ls_secs = 7;
   */
  lsSecs: number;

  /**
   *
   * Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
   * Technical Details: ESP32 Only 0 for default of 10 seconds
   *
   * @generated from field: uint32 min_wake_secs = 8;
   */
  minWakeSecs: number;

  /**
   *
   * I2C address of INA_2XX to use for reading device battery voltage
   *
   * @generated from field: uint32 device_battery_ina_address = 9;
   */
  deviceBatteryInaAddress: number;

  /**
   *
   * If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
   * Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
   *
   * @generated from field: uint64 powermon_enables = 32;
   */
  powermonEnables: bigint;
};

/**
 * Describes the message meshtastic.Config.PowerConfig.
 * Use `create(Config_PowerConfigSchema)` to create a new message.
 */
export const Config_PowerConfigSchema: GenMessage<Config_PowerConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 2);

/**
 *
 * Network Config
 *
 * @generated from message meshtastic.Config.NetworkConfig
 */
export type Config_NetworkConfig = Message<"meshtastic.Config.NetworkConfig"> & {
  /**
   *
   * Enable WiFi (disables Bluetooth)
   *
   * @generated from field: bool wifi_enabled = 1;
   */
  wifiEnabled: boolean;

  /**
   *
   * If set, this node will try to join the specified wifi network and
   * acquire an address via DHCP
   *
   * @generated from field: string wifi_ssid = 3;
   */
  wifiSsid: string;

  /**
   *
   * If set, will be use to authenticate to the named wifi
   *
   * @generated from field: string wifi_psk = 4;
   */
  wifiPsk: string;

  /**
   *
   * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
   *
   * @generated from field: string ntp_server = 5;
   */
  ntpServer: string;

  /**
   *
   * Enable Ethernet
   *
   * @generated from field: bool eth_enabled = 6;
   */
  ethEnabled: boolean;

  /**
   *
   * acquire an address via DHCP or assign static
   *
   * @generated from field: meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;
   */
  addressMode: Config_NetworkConfig_AddressMode;

  /**
   *
   * struct to keep static address
   *
   * @generated from field: meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;
   */
  ipv4Config?: Config_NetworkConfig_IpV4Config;

  /**
   *
   * rsyslog Server and Port
   *
   * @generated from field: string rsyslog_server = 9;
   */
  rsyslogServer: string;

  /**
   *
   * Flags for enabling/disabling network protocols
   *
   * @generated from field: uint32 enabled_protocols = 10;
   */
  enabledProtocols: number;
};

/**
 * Describes the message meshtastic.Config.NetworkConfig.
 * Use `create(Config_NetworkConfigSchema)` to create a new message.
 */
export const Config_NetworkConfigSchema: GenMessage<Config_NetworkConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 3);

/**
 * @generated from message meshtastic.Config.NetworkConfig.IpV4Config
 */
export type Config_NetworkConfig_IpV4Config = Message<"meshtastic.Config.NetworkConfig.IpV4Config"> & {
  /**
   *
   * Static IP address
   *
   * @generated from field: fixed32 ip = 1;
   */
  ip: number;

  /**
   *
   * Static gateway address
   *
   * @generated from field: fixed32 gateway = 2;
   */
  gateway: number;

  /**
   *
   * Static subnet mask
   *
   * @generated from field: fixed32 subnet = 3;
   */
  subnet: number;

  /**
   *
   * Static DNS server address
   *
   * @generated from field: fixed32 dns = 4;
   */
  dns: number;
};

/**
 * Describes the message meshtastic.Config.NetworkConfig.IpV4Config.
 * Use `create(Config_NetworkConfig_IpV4ConfigSchema)` to create a new message.
 */
export const Config_NetworkConfig_IpV4ConfigSchema: GenMessage<Config_NetworkConfig_IpV4Config> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 3, 0);

/**
 * @generated from enum meshtastic.Config.NetworkConfig.AddressMode
 */
export enum Config_NetworkConfig_AddressMode {
  /**
   *
   * obtain ip address via DHCP
   *
   * @generated from enum value: DHCP = 0;
   */
  DHCP = 0,

  /**
   *
   * use static ip address
   *
   * @generated from enum value: STATIC = 1;
   */
  STATIC = 1,
}

/**
 * Describes the enum meshtastic.Config.NetworkConfig.AddressMode.
 */
export const Config_NetworkConfig_AddressModeSchema: GenEnum<Config_NetworkConfig_AddressMode> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 3, 0);

/**
 *
 * Available flags auxiliary network protocols
 *
 * @generated from enum meshtastic.Config.NetworkConfig.ProtocolFlags
 */
export enum Config_NetworkConfig_ProtocolFlags {
  /**
   *
   * Do not broadcast packets over any network protocol
   *
   * @generated from enum value: NO_BROADCAST = 0;
   */
  NO_BROADCAST = 0,

  /**
   *
   * Enable broadcasting packets via UDP over the local network
   *
   * @generated from enum value: UDP_BROADCAST = 1;
   */
  UDP_BROADCAST = 1,
}

/**
 * Describes the enum meshtastic.Config.NetworkConfig.ProtocolFlags.
 */
export const Config_NetworkConfig_ProtocolFlagsSchema: GenEnum<Config_NetworkConfig_ProtocolFlags> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 3, 1);

/**
 *
 * Display Config
 *
 * @generated from message meshtastic.Config.DisplayConfig
 */
export type Config_DisplayConfig = Message<"meshtastic.Config.DisplayConfig"> & {
  /**
   *
   * Number of seconds the screen stays on after pressing the user button or receiving a message
   * 0 for default of one minute MAXUINT for always on
   *
   * @generated from field: uint32 screen_on_secs = 1;
   */
  screenOnSecs: number;

  /**
   *
   * How the GPS coordinates are formatted on the OLED screen.
   *
   * @generated from field: meshtastic.Config.DisplayConfig.GpsCoordinateFormat gps_format = 2;
   */
  gpsFormat: Config_DisplayConfig_GpsCoordinateFormat;

  /**
   *
   * Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
   * Potentially useful for devices without user buttons.
   *
   * @generated from field: uint32 auto_screen_carousel_secs = 3;
   */
  autoScreenCarouselSecs: number;

  /**
   *
   * If this is set, the displayed compass will always point north. if unset, the old behaviour
   * (top of display is heading direction) is used.
   *
   * @generated from field: bool compass_north_top = 4;
   */
  compassNorthTop: boolean;

  /**
   *
   * Flip screen vertically, for cases that mount the screen upside down
   *
   * @generated from field: bool flip_screen = 5;
   */
  flipScreen: boolean;

  /**
   *
   * Perferred display units
   *
   * @generated from field: meshtastic.Config.DisplayConfig.DisplayUnits units = 6;
   */
  units: Config_DisplayConfig_DisplayUnits;

  /**
   *
   * Override auto-detect in screen
   *
   * @generated from field: meshtastic.Config.DisplayConfig.OledType oled = 7;
   */
  oled: Config_DisplayConfig_OledType;

  /**
   *
   * Display Mode
   *
   * @generated from field: meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;
   */
  displaymode: Config_DisplayConfig_DisplayMode;

  /**
   *
   * Print first line in pseudo-bold? FALSE is original style, TRUE is bold
   *
   * @generated from field: bool heading_bold = 9;
   */
  headingBold: boolean;

  /**
   *
   * Should we wake the screen up on accelerometer detected motion or tap
   *
   * @generated from field: bool wake_on_tap_or_motion = 10;
   */
  wakeOnTapOrMotion: boolean;

  /**
   *
   * Indicates how to rotate or invert the compass output to accurate display on the display.
   *
   * @generated from field: meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;
   */
  compassOrientation: Config_DisplayConfig_CompassOrientation;

  /**
   *
   * If false (default), the device will display the time in 24-hour format on screen.
   * If true, the device will display the time in 12-hour format on screen.
   *
   * @generated from field: bool use_12h_clock = 12;
   */
  use12hClock: boolean;
};

/**
 * Describes the message meshtastic.Config.DisplayConfig.
 * Use `create(Config_DisplayConfigSchema)` to create a new message.
 */
export const Config_DisplayConfigSchema: GenMessage<Config_DisplayConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 4);

/**
 *
 * How the GPS coordinates are displayed on the OLED screen.
 *
 * @generated from enum meshtastic.Config.DisplayConfig.GpsCoordinateFormat
 */
export enum Config_DisplayConfig_GpsCoordinateFormat {
  /**
   *
   * GPS coordinates are displayed in the normal decimal degrees format:
   * DD.DDDDDD DDD.DDDDDD
   *
   * @generated from enum value: DEC = 0;
   */
  DEC = 0,

  /**
   *
   * GPS coordinates are displayed in the degrees minutes seconds format:
   * DD°MM'SS"C DDD°MM'SS"C, where C is the compass point representing the locations quadrant
   *
   * @generated from enum value: DMS = 1;
   */
  DMS = 1,

  /**
   *
   * Universal Transverse Mercator format:
   * ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
   *
   * @generated from enum value: UTM = 2;
   */
  UTM = 2,

  /**
   *
   * Military Grid Reference System format:
   * ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square,
   * E is easting, N is northing
   *
   * @generated from enum value: MGRS = 3;
   */
  MGRS = 3,

  /**
   *
   * Open Location Code (aka Plus Codes).
   *
   * @generated from enum value: OLC = 4;
   */
  OLC = 4,

  /**
   *
   * Ordnance Survey Grid Reference (the National Grid System of the UK).
   * Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square,
   * E is the easting, N is the northing
   *
   * @generated from enum value: OSGR = 5;
   */
  OSGR = 5,
}

/**
 * Describes the enum meshtastic.Config.DisplayConfig.GpsCoordinateFormat.
 */
export const Config_DisplayConfig_GpsCoordinateFormatSchema: GenEnum<Config_DisplayConfig_GpsCoordinateFormat> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 4, 0);

/**
 *
 * Unit display preference
 *
 * @generated from enum meshtastic.Config.DisplayConfig.DisplayUnits
 */
export enum Config_DisplayConfig_DisplayUnits {
  /**
   *
   * Metric (Default)
   *
   * @generated from enum value: METRIC = 0;
   */
  METRIC = 0,

  /**
   *
   * Imperial
   *
   * @generated from enum value: IMPERIAL = 1;
   */
  IMPERIAL = 1,
}

/**
 * Describes the enum meshtastic.Config.DisplayConfig.DisplayUnits.
 */
export const Config_DisplayConfig_DisplayUnitsSchema: GenEnum<Config_DisplayConfig_DisplayUnits> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 4, 1);

/**
 *
 * Override OLED outo detect with this if it fails.
 *
 * @generated from enum meshtastic.Config.DisplayConfig.OledType
 */
export enum Config_DisplayConfig_OledType {
  /**
   *
   * Default / Auto
   *
   * @generated from enum value: OLED_AUTO = 0;
   */
  OLED_AUTO = 0,

  /**
   *
   * Default / Auto
   *
   * @generated from enum value: OLED_SSD1306 = 1;
   */
  OLED_SSD1306 = 1,

  /**
   *
   * Default / Auto
   *
   * @generated from enum value: OLED_SH1106 = 2;
   */
  OLED_SH1106 = 2,

  /**
   *
   * Can not be auto detected but set by proto. Used for 128x128 screens
   *
   * @generated from enum value: OLED_SH1107 = 3;
   */
  OLED_SH1107 = 3,
}

/**
 * Describes the enum meshtastic.Config.DisplayConfig.OledType.
 */
export const Config_DisplayConfig_OledTypeSchema: GenEnum<Config_DisplayConfig_OledType> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 4, 2);

/**
 * @generated from enum meshtastic.Config.DisplayConfig.DisplayMode
 */
export enum Config_DisplayConfig_DisplayMode {
  /**
   *
   * Default. The old style for the 128x64 OLED screen
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   *
   * Rearrange display elements to cater for bicolor OLED displays
   *
   * @generated from enum value: TWOCOLOR = 1;
   */
  TWOCOLOR = 1,

  /**
   *
   * Same as TwoColor, but with inverted top bar. Not so good for Epaper displays
   *
   * @generated from enum value: INVERTED = 2;
   */
  INVERTED = 2,

  /**
   *
   * TFT Full Color Displays (not implemented yet)
   *
   * @generated from enum value: COLOR = 3;
   */
  COLOR = 3,
}

/**
 * Describes the enum meshtastic.Config.DisplayConfig.DisplayMode.
 */
export const Config_DisplayConfig_DisplayModeSchema: GenEnum<Config_DisplayConfig_DisplayMode> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 4, 3);

/**
 * @generated from enum meshtastic.Config.DisplayConfig.CompassOrientation
 */
export enum Config_DisplayConfig_CompassOrientation {
  /**
   *
   * The compass and the display are in the same orientation.
   *
   * @generated from enum value: DEGREES_0 = 0;
   */
  DEGREES_0 = 0,

  /**
   *
   * Rotate the compass by 90 degrees.
   *
   * @generated from enum value: DEGREES_90 = 1;
   */
  DEGREES_90 = 1,

  /**
   *
   * Rotate the compass by 180 degrees.
   *
   * @generated from enum value: DEGREES_180 = 2;
   */
  DEGREES_180 = 2,

  /**
   *
   * Rotate the compass by 270 degrees.
   *
   * @generated from enum value: DEGREES_270 = 3;
   */
  DEGREES_270 = 3,

  /**
   *
   * Don't rotate the compass, but invert the result.
   *
   * @generated from enum value: DEGREES_0_INVERTED = 4;
   */
  DEGREES_0_INVERTED = 4,

  /**
   *
   * Rotate the compass by 90 degrees and invert.
   *
   * @generated from enum value: DEGREES_90_INVERTED = 5;
   */
  DEGREES_90_INVERTED = 5,

  /**
   *
   * Rotate the compass by 180 degrees and invert.
   *
   * @generated from enum value: DEGREES_180_INVERTED = 6;
   */
  DEGREES_180_INVERTED = 6,

  /**
   *
   * Rotate the compass by 270 degrees and invert.
   *
   * @generated from enum value: DEGREES_270_INVERTED = 7;
   */
  DEGREES_270_INVERTED = 7,
}

/**
 * Describes the enum meshtastic.Config.DisplayConfig.CompassOrientation.
 */
export const Config_DisplayConfig_CompassOrientationSchema: GenEnum<Config_DisplayConfig_CompassOrientation> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 4, 4);

/**
 *
 * Lora Config
 *
 * @generated from message meshtastic.Config.LoRaConfig
 */
export type Config_LoRaConfig = Message<"meshtastic.Config.LoRaConfig"> & {
  /**
   *
   * When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
   * will be taked from their respective manually defined fields
   *
   * @generated from field: bool use_preset = 1;
   */
  usePreset: boolean;

  /**
   *
   * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
   * As a heuristic: If bandwidth is specified, do not use modem_config.
   * Because protobufs take ZERO space when the value is zero this works out nicely.
   * This value is replaced by bandwidth/spread_factor/coding_rate.
   * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
   *
   * @generated from field: meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;
   */
  modemPreset: Config_LoRaConfig_ModemPreset;

  /**
   *
   * Bandwidth in MHz
   * Certain bandwidth numbers are 'special' and will be converted to the
   * appropriate floating point value: 31 -> 31.25MHz
   *
   * @generated from field: uint32 bandwidth = 3;
   */
  bandwidth: number;

  /**
   *
   * A number from 7 to 12.
   * Indicates number of chirps per symbol as 1<<spread_factor.
   *
   * @generated from field: uint32 spread_factor = 4;
   */
  spreadFactor: number;

  /**
   *
   * The denominator of the coding rate.
   * ie for 4/5, the value is 5. 4/8 the value is 8.
   *
   * @generated from field: uint32 coding_rate = 5;
   */
  codingRate: number;

  /**
   *
   * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
   * A frequency offset that is added to to the calculated band center frequency.
   * Used to correct for crystal calibration errors.
   *
   * @generated from field: float frequency_offset = 6;
   */
  frequencyOffset: number;

  /**
   *
   * The region code for the radio (US, CN, EU433, etc...)
   *
   * @generated from field: meshtastic.Config.LoRaConfig.RegionCode region = 7;
   */
  region: Config_LoRaConfig_RegionCode;

  /**
   *
   * Maximum number of hops. This can't be greater than 7.
   * Default of 3
   * Attempting to set a value > 7 results in the default
   *
   * @generated from field: uint32 hop_limit = 8;
   */
  hopLimit: number;

  /**
   *
   * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
   * Defaults to false
   *
   * @generated from field: bool tx_enabled = 9;
   */
  txEnabled: boolean;

  /**
   *
   * If zero, then use default max legal continuous power (ie. something that won't
   * burn out the radio hardware)
   * In most cases you should use zero here.
   * Units are in dBm.
   *
   * @generated from field: int32 tx_power = 10;
   */
  txPower: number;

  /**
   *
   * This controls the actual hardware frequency the radio transmits on.
   * Most users should never need to be exposed to this field/concept.
   * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
   * If ZERO then the rule is "use the old channel name hash based
   * algorithm to derive the channel number")
   * If using the hash algorithm the channel number will be: hash(channel_name) %
   * NUM_CHANNELS (Where num channels depends on the regulatory region).
   *
   * @generated from field: uint32 channel_num = 11;
   */
  channelNum: number;

  /**
   *
   * If true, duty cycle limits will be exceeded and thus you're possibly not following
   * the local regulations if you're not a HAM.
   * Has no effect if the duty cycle of the used region is 100%.
   *
   * @generated from field: bool override_duty_cycle = 12;
   */
  overrideDutyCycle: boolean;

  /**
   *
   * If true, sets RX boosted gain mode on SX126X based radios
   *
   * @generated from field: bool sx126x_rx_boosted_gain = 13;
   */
  sx126xRxBoostedGain: boolean;

  /**
   *
   * This parameter is for advanced users and licensed HAM radio operators.
   * Ignore Channel Calculation and use this frequency instead. The frequency_offset
   * will still be applied. This will allow you to use out-of-band frequencies.
   * Please respect your local laws and regulations. If you are a HAM, make sure you
   * enable HAM mode and turn off encryption.
   *
   * @generated from field: float override_frequency = 14;
   */
  overrideFrequency: number;

  /**
   *
   * If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
   *
   * @generated from field: bool pa_fan_disabled = 15;
   */
  paFanDisabled: boolean;

  /**
   *
   * For testing it is useful sometimes to force a node to never listen to
   * particular other nodes (simulating radio out of range). All nodenums listed
   * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
   *
   * @generated from field: repeated uint32 ignore_incoming = 103;
   */
  ignoreIncoming: number[];

  /**
   *
   * If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
   *
   * @generated from field: bool ignore_mqtt = 104;
   */
  ignoreMqtt: boolean;

  /**
   *
   * Sets the ok_to_mqtt bit on outgoing packets
   *
   * @generated from field: bool config_ok_to_mqtt = 105;
   */
  configOkToMqtt: boolean;
};

/**
 * Describes the message meshtastic.Config.LoRaConfig.
 * Use `create(Config_LoRaConfigSchema)` to create a new message.
 */
export const Config_LoRaConfigSchema: GenMessage<Config_LoRaConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 5);

/**
 * @generated from enum meshtastic.Config.LoRaConfig.RegionCode
 */
export enum Config_LoRaConfig_RegionCode {
  /**
   *
   * Region is not set
   *
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   *
   * United States
   *
   * @generated from enum value: US = 1;
   */
  US = 1,

  /**
   *
   * European Union 433mhz
   *
   * @generated from enum value: EU_433 = 2;
   */
  EU_433 = 2,

  /**
   *
   * European Union 868mhz
   *
   * @generated from enum value: EU_868 = 3;
   */
  EU_868 = 3,

  /**
   *
   * China
   *
   * @generated from enum value: CN = 4;
   */
  CN = 4,

  /**
   *
   * Japan
   *
   * @generated from enum value: JP = 5;
   */
  JP = 5,

  /**
   *
   * Australia / New Zealand
   *
   * @generated from enum value: ANZ = 6;
   */
  ANZ = 6,

  /**
   *
   * Korea
   *
   * @generated from enum value: KR = 7;
   */
  KR = 7,

  /**
   *
   * Taiwan
   *
   * @generated from enum value: TW = 8;
   */
  TW = 8,

  /**
   *
   * Russia
   *
   * @generated from enum value: RU = 9;
   */
  RU = 9,

  /**
   *
   * India
   *
   * @generated from enum value: IN = 10;
   */
  IN = 10,

  /**
   *
   * New Zealand 865mhz
   *
   * @generated from enum value: NZ_865 = 11;
   */
  NZ_865 = 11,

  /**
   *
   * Thailand
   *
   * @generated from enum value: TH = 12;
   */
  TH = 12,

  /**
   *
   * WLAN Band
   *
   * @generated from enum value: LORA_24 = 13;
   */
  LORA_24 = 13,

  /**
   *
   * Ukraine 433mhz
   *
   * @generated from enum value: UA_433 = 14;
   */
  UA_433 = 14,

  /**
   *
   * Ukraine 868mhz
   *
   * @generated from enum value: UA_868 = 15;
   */
  UA_868 = 15,

  /**
   *
   * Malaysia 433mhz
   *
   * @generated from enum value: MY_433 = 16;
   */
  MY_433 = 16,

  /**
   *
   * Malaysia 919mhz
   *
   * @generated from enum value: MY_919 = 17;
   */
  MY_919 = 17,

  /**
   *
   * Singapore 923mhz
   *
   * @generated from enum value: SG_923 = 18;
   */
  SG_923 = 18,

  /**
   *
   * Philippines 433mhz
   *
   * @generated from enum value: PH_433 = 19;
   */
  PH_433 = 19,

  /**
   *
   * Philippines 868mhz
   *
   * @generated from enum value: PH_868 = 20;
   */
  PH_868 = 20,

  /**
   *
   * Philippines 915mhz
   *
   * @generated from enum value: PH_915 = 21;
   */
  PH_915 = 21,
}

/**
 * Describes the enum meshtastic.Config.LoRaConfig.RegionCode.
 */
export const Config_LoRaConfig_RegionCodeSchema: GenEnum<Config_LoRaConfig_RegionCode> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 5, 0);

/**
 *
 * Standard predefined channel settings
 * Note: these mappings must match ModemPreset Choice in the device code.
 *
 * @generated from enum meshtastic.Config.LoRaConfig.ModemPreset
 */
export enum Config_LoRaConfig_ModemPreset {
  /**
   *
   * Long Range - Fast
   *
   * @generated from enum value: LONG_FAST = 0;
   */
  LONG_FAST = 0,

  /**
   *
   * Long Range - Slow
   *
   * @generated from enum value: LONG_SLOW = 1;
   */
  LONG_SLOW = 1,

  /**
   *
   * Very Long Range - Slow
   * Deprecated in 2.5: Works only with txco and is unusably slow
   *
   * @generated from enum value: VERY_LONG_SLOW = 2 [deprecated = true];
   * @deprecated
   */
  VERY_LONG_SLOW = 2,

  /**
   *
   * Medium Range - Slow
   *
   * @generated from enum value: MEDIUM_SLOW = 3;
   */
  MEDIUM_SLOW = 3,

  /**
   *
   * Medium Range - Fast
   *
   * @generated from enum value: MEDIUM_FAST = 4;
   */
  MEDIUM_FAST = 4,

  /**
   *
   * Short Range - Slow
   *
   * @generated from enum value: SHORT_SLOW = 5;
   */
  SHORT_SLOW = 5,

  /**
   *
   * Short Range - Fast
   *
   * @generated from enum value: SHORT_FAST = 6;
   */
  SHORT_FAST = 6,

  /**
   *
   * Long Range - Moderately Fast
   *
   * @generated from enum value: LONG_MODERATE = 7;
   */
  LONG_MODERATE = 7,

  /**
   *
   * Short Range - Turbo
   * This is the fastest preset and the only one with 500kHz bandwidth.
   * It is not legal to use in all regions due to this wider bandwidth.
   *
   * @generated from enum value: SHORT_TURBO = 8;
   */
  SHORT_TURBO = 8,
}

/**
 * Describes the enum meshtastic.Config.LoRaConfig.ModemPreset.
 */
export const Config_LoRaConfig_ModemPresetSchema: GenEnum<Config_LoRaConfig_ModemPreset> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 5, 1);

/**
 * @generated from message meshtastic.Config.BluetoothConfig
 */
export type Config_BluetoothConfig = Message<"meshtastic.Config.BluetoothConfig"> & {
  /**
   *
   * Enable Bluetooth on the device
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * Determines the pairing strategy for the device
   *
   * @generated from field: meshtastic.Config.BluetoothConfig.PairingMode mode = 2;
   */
  mode: Config_BluetoothConfig_PairingMode;

  /**
   *
   * Specified PIN for PairingMode.FixedPin
   *
   * @generated from field: uint32 fixed_pin = 3;
   */
  fixedPin: number;
};

/**
 * Describes the message meshtastic.Config.BluetoothConfig.
 * Use `create(Config_BluetoothConfigSchema)` to create a new message.
 */
export const Config_BluetoothConfigSchema: GenMessage<Config_BluetoothConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 6);

/**
 * @generated from enum meshtastic.Config.BluetoothConfig.PairingMode
 */
export enum Config_BluetoothConfig_PairingMode {
  /**
   *
   * Device generates a random PIN that will be shown on the screen of the device for pairing
   *
   * @generated from enum value: RANDOM_PIN = 0;
   */
  RANDOM_PIN = 0,

  /**
   *
   * Device requires a specified fixed PIN for pairing
   *
   * @generated from enum value: FIXED_PIN = 1;
   */
  FIXED_PIN = 1,

  /**
   *
   * Device requires no PIN for pairing
   *
   * @generated from enum value: NO_PIN = 2;
   */
  NO_PIN = 2,
}

/**
 * Describes the enum meshtastic.Config.BluetoothConfig.PairingMode.
 */
export const Config_BluetoothConfig_PairingModeSchema: GenEnum<Config_BluetoothConfig_PairingMode> = /*@__PURE__*/
  enumDesc(file_meshtastic_config, 0, 6, 0);

/**
 * @generated from message meshtastic.Config.SecurityConfig
 */
export type Config_SecurityConfig = Message<"meshtastic.Config.SecurityConfig"> & {
  /**
   *
   * The public key of the user's device.
   * Sent out to other nodes on the mesh to allow them to compute a shared secret key.
   *
   * @generated from field: bytes public_key = 1;
   */
  publicKey: Uint8Array;

  /**
   *
   * The private key of the device.
   * Used to create a shared key with a remote device.
   *
   * @generated from field: bytes private_key = 2;
   */
  privateKey: Uint8Array;

  /**
   *
   * The public key authorized to send admin messages to this node.
   *
   * @generated from field: repeated bytes admin_key = 3;
   */
  adminKey: Uint8Array[];

  /**
   *
   * If true, device is considered to be "managed" by a mesh administrator via admin messages
   * Device is managed by a mesh administrator.
   *
   * @generated from field: bool is_managed = 4;
   */
  isManaged: boolean;

  /**
   *
   * Serial Console over the Stream API."
   *
   * @generated from field: bool serial_enabled = 5;
   */
  serialEnabled: boolean;

  /**
   *
   * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
   * Output live debug logging over serial or bluetooth is set to true.
   *
   * @generated from field: bool debug_log_api_enabled = 6;
   */
  debugLogApiEnabled: boolean;

  /**
   *
   * Allow incoming device control over the insecure legacy admin channel.
   *
   * @generated from field: bool admin_channel_enabled = 8;
   */
  adminChannelEnabled: boolean;
};

/**
 * Describes the message meshtastic.Config.SecurityConfig.
 * Use `create(Config_SecurityConfigSchema)` to create a new message.
 */
export const Config_SecurityConfigSchema: GenMessage<Config_SecurityConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 7);

/**
 *
 * Blank config request, strictly for getting the session key
 *
 * @generated from message meshtastic.Config.SessionkeyConfig
 */
export type Config_SessionkeyConfig = Message<"meshtastic.Config.SessionkeyConfig"> & {
};

/**
 * Describes the message meshtastic.Config.SessionkeyConfig.
 * Use `create(Config_SessionkeyConfigSchema)` to create a new message.
 */
export const Config_SessionkeyConfigSchema: GenMessage<Config_SessionkeyConfig> = /*@__PURE__*/
  messageDesc(file_meshtastic_config, 0, 8);

