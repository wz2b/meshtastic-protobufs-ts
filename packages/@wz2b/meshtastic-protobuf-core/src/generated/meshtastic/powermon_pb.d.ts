// @generated by protoc-gen-es v2.2.5 with parameter "target=js+dts,import_extension=js"
// @generated from file meshtastic/powermon.proto (package meshtastic, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file meshtastic/powermon.proto.
 */
export declare const file_meshtastic_powermon: GenFile;

/**
 * Note: There are no 'PowerMon' messages normally in use (PowerMons are sent only as structured logs - slogs).
 * But we wrap our State enum in this message to effectively nest a namespace (without our linter yelling at us)
 *
 * @generated from message meshtastic.PowerMon
 */
export declare type PowerMon = Message<"meshtastic.PowerMon"> & {
};

/**
 * Describes the message meshtastic.PowerMon.
 * Use `create(PowerMonSchema)` to create a new message.
 */
export declare const PowerMonSchema: GenMessage<PowerMon>;

/**
 * Any significant power changing event in meshtastic should be tagged with a powermon state transition.
 * If you are making new meshtastic features feel free to add new entries at the end of this definition.
 *
 * @generated from enum meshtastic.PowerMon.State
 */
export enum PowerMon_State {
  /**
   * @generated from enum value: None = 0;
   */
  None = 0,

  /**
   * @generated from enum value: CPU_DeepSleep = 1;
   */
  CPU_DeepSleep = 1,

  /**
   * @generated from enum value: CPU_LightSleep = 2;
   */
  CPU_LightSleep = 2,

  /**
   *
   * The external Vext1 power is on.  Many boards have auxillary power rails that the CPU turns on only
   * occasionally.  In cases where that rail has multiple devices on it we usually want to have logging on
   * the state of that rail as an independent record.
   * For instance on the Heltec Tracker 1.1 board, this rail is the power source for the GPS and screen.
   *
   * The log messages will be short and complete (see PowerMon.Event in the protobufs for details).
   * something like "S:PM:C,0x00001234,REASON" where the hex number is the bitmask of all current states.
   * (We use a bitmask for states so that if a log message gets lost it won't be fatal)
   *
   * @generated from enum value: Vext1_On = 4;
   */
  Vext1_On = 4,

  /**
   * @generated from enum value: Lora_RXOn = 8;
   */
  Lora_RXOn = 8,

  /**
   * @generated from enum value: Lora_TXOn = 16;
   */
  Lora_TXOn = 16,

  /**
   * @generated from enum value: Lora_RXActive = 32;
   */
  Lora_RXActive = 32,

  /**
   * @generated from enum value: BT_On = 64;
   */
  BT_On = 64,

  /**
   * @generated from enum value: LED_On = 128;
   */
  LED_On = 128,

  /**
   * @generated from enum value: Screen_On = 256;
   */
  Screen_On = 256,

  /**
   * @generated from enum value: Screen_Drawing = 512;
   */
  Screen_Drawing = 512,

  /**
   * @generated from enum value: Wifi_On = 1024;
   */
  Wifi_On = 1024,

  /**
   *
   * GPS is actively trying to find our location
   * See GPSPowerState for more details
   *
   * @generated from enum value: GPS_Active = 2048;
   */
  GPS_Active = 2048,
}

/**
 * Describes the enum meshtastic.PowerMon.State.
 */
export declare const PowerMon_StateSchema: GenEnum<PowerMon_State>;

/**
 *
 * PowerStress testing support via the C++ PowerStress module
 *
 * @generated from message meshtastic.PowerStressMessage
 */
export declare type PowerStressMessage = Message<"meshtastic.PowerStressMessage"> & {
  /**
   *
   * What type of HardwareMessage is this?
   *
   * @generated from field: meshtastic.PowerStressMessage.Opcode cmd = 1;
   */
  cmd: PowerStressMessage_Opcode;

  /**
   * @generated from field: float num_seconds = 2;
   */
  numSeconds: number;
};

/**
 * Describes the message meshtastic.PowerStressMessage.
 * Use `create(PowerStressMessageSchema)` to create a new message.
 */
export declare const PowerStressMessageSchema: GenMessage<PowerStressMessage>;

/**
 *
 * What operation would we like the UUT to perform.
 * note: senders should probably set want_response in their request packets, so that they can know when the state
 * machine has started processing their request
 *
 * @generated from enum meshtastic.PowerStressMessage.Opcode
 */
export enum PowerStressMessage_Opcode {
  /**
   *
   * Unset/unused
   *
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   * Print board version slog and send an ack that we are alive and ready to process commands
   *
   * @generated from enum value: PRINT_INFO = 1;
   */
  PRINT_INFO = 1,

  /**
   * Try to turn off all automatic processing of packets, screen, sleeping, etc (to make it easier to measure in isolation)
   *
   * @generated from enum value: FORCE_QUIET = 2;
   */
  FORCE_QUIET = 2,

  /**
   * Stop powerstress processing - probably by just rebooting the board
   *
   * @generated from enum value: END_QUIET = 3;
   */
  END_QUIET = 3,

  /**
   * Turn the screen on
   *
   * @generated from enum value: SCREEN_ON = 16;
   */
  SCREEN_ON = 16,

  /**
   * Turn the screen off
   *
   * @generated from enum value: SCREEN_OFF = 17;
   */
  SCREEN_OFF = 17,

  /**
   * Let the CPU run but we assume mostly idling for num_seconds
   *
   * @generated from enum value: CPU_IDLE = 32;
   */
  CPU_IDLE = 32,

  /**
   * Force deep sleep for FIXME seconds
   *
   * @generated from enum value: CPU_DEEPSLEEP = 33;
   */
  CPU_DEEPSLEEP = 33,

  /**
   * Spin the CPU as fast as possible for num_seconds
   *
   * @generated from enum value: CPU_FULLON = 34;
   */
  CPU_FULLON = 34,

  /**
   * Turn the LED on for num_seconds (and leave it on - for baseline power measurement purposes)
   *
   * @generated from enum value: LED_ON = 48;
   */
  LED_ON = 48,

  /**
   * Force the LED off for num_seconds
   *
   * @generated from enum value: LED_OFF = 49;
   */
  LED_OFF = 49,

  /**
   * Completely turn off the LORA radio for num_seconds
   *
   * @generated from enum value: LORA_OFF = 64;
   */
  LORA_OFF = 64,

  /**
   * Send Lora packets for num_seconds
   *
   * @generated from enum value: LORA_TX = 65;
   */
  LORA_TX = 65,

  /**
   * Receive Lora packets for num_seconds (node will be mostly just listening, unless an external agent is helping stress this by sending packets on the current channel)
   *
   * @generated from enum value: LORA_RX = 66;
   */
  LORA_RX = 66,

  /**
   * Turn off the BT radio for num_seconds
   *
   * @generated from enum value: BT_OFF = 80;
   */
  BT_OFF = 80,

  /**
   * Turn on the BT radio for num_seconds
   *
   * @generated from enum value: BT_ON = 81;
   */
  BT_ON = 81,

  /**
   * Turn off the WIFI radio for num_seconds
   *
   * @generated from enum value: WIFI_OFF = 96;
   */
  WIFI_OFF = 96,

  /**
   * Turn on the WIFI radio for num_seconds
   *
   * @generated from enum value: WIFI_ON = 97;
   */
  WIFI_ON = 97,

  /**
   * Turn off the GPS radio for num_seconds
   *
   * @generated from enum value: GPS_OFF = 112;
   */
  GPS_OFF = 112,

  /**
   * Turn on the GPS radio for num_seconds
   *
   * @generated from enum value: GPS_ON = 113;
   */
  GPS_ON = 113,
}

/**
 * Describes the enum meshtastic.PowerStressMessage.Opcode.
 */
export declare const PowerStressMessage_OpcodeSchema: GenEnum<PowerStressMessage_Opcode>;

